% Document: ./rm_io
% Source: ./mywork/
% Generated with ROBODoc Version 4.99.36 (Jul 28 2009)
\section{Attributes/ncdf\_getatt}
\textsl{[ Subroutines ]}

\label{ch:robo0}
\label{ch:Attributes_ncdf_getatt}
\index{unsorted!ncdf\_getatt}\index{Subroutines!ncdf\_getatt}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getatt - Read an attribute from a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_getatt(attname, value)              ! global attribute
      - or -
    call ncdf_getatt(varname, attname, value)     ! variable's attribute
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine reads attribute data from the current netCDF file.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    varname   Name of variable to which the attribute belongs. If varname
                 is not given, a global attribute is read.
    attname   Name of attribute to be read.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    value
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getatt_alloc
    ncdf_putatt
\end{Verbatim}
\section{Attributes/ncdf\_getatt\_alloc}
\textsl{[ Subroutines ]}

\label{ch:robo1}
\label{ch:Attributes_ncdf_getatt_alloc}
\index{unsorted!ncdf\_getatt\_alloc}\index{Subroutines!ncdf\_getatt\_alloc}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getatt_alloc - Read an attribute from a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    call ncdf_getatt(attname, value)              ! global attribute
      - or -
    call ncdf_getatt(varname, attname, value)     ! variable's attribute
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine reads attribute data from the current netCDF file.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    varname   Name of variable to which the attribute belongs. If varname
                 is not given, a global attribute is read.
    attname   Name of attribute to be read.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    value
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getatt
    ncdf_putatt
\end{Verbatim}
\section{Attributes/ncdf\_putatt}
\textsl{[ Subroutines ]}

\label{ch:robo2}
\label{ch:Attributes_ncdf_putatt}
\index{unsorted!ncdf\_putatt}\index{Subroutines!ncdf\_putatt}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_putatt - Write an attribute to a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_putatt(attname, value)              ! global attribute
      - or -
    call ncdf_putatt(varname, attname, value)     ! variable's attribute
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine writes attribute data from the current netCDF file.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    varname   Name of variable to which the attribute belongs. If varname
                 is not given, a global attribute is written.
    attname   Name of attribute to be written.
    value     Value(s) to be written.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getatt
    ncdf_getatt_alloc
\end{Verbatim}
\section{BUFR/BUFRUTILS/BUFRutils}
\textsl{[ Modules ]}

\label{ch:robo3}
\label{ch:BUFR_BUFRUTILS_BUFRutils}
\index{unsorted!BUFRUTILS/BUFRutils}\index{Modules!BUFRUTILS/BUFRutils}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   BUFRutils    (BUFRutils.f90)

 SYNOPIS
   Module providing BUFR utility routines

   USE BUFRutils
   CALL ConvertDescriptor ( Descr, FXXYYY,  F,X,Y, in )
   CALL ConvertMOtoEC     ( nExpDescr, ExpDescr, nObs,
                            Values1, Values2, pValues, cValues )
   CALL ExtractMOinfo     ( cBUF, Supp, Sec0, Sec1, Sec2,
                            Sec3, Sec4, Sec5, nDescr, Descr )
   Cnt = ReplicationCount ( ExpDescr, Values, KeyDescr )
\end{Verbatim}
\section{BUFR/BUFRUTILS/ConvertDescriptor}
\textsl{[ Subroutines ]}

\label{ch:robo4}
\label{ch:BUFR_BUFRUTILS_ConvertDescriptor}
\index{unsorted!BUFRUTILS/ConvertDescriptor}\index{Subroutines!BUFRUTILS/ConvertDescriptor}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ConvertDescriptor    (BUFRutils.f90)

 SYNOPIS
   Convert a BUFR descriptor between 16-bit integer, 6-digit readable
   & individual element forms

   INTEGER :: descr, fxxyyy, f,x,y, ind
   CALL convertdescriptor( descr, fxxyyy, f,x,y, ind )
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   Descr    int  descriptor in 16-bit integer (BUFR) form   (ind=1)
   FXXYYY   int  descriptor in 6-digit readable form fxxyyy (ind=2)
   F, X, Y  int  individual elements of descriptor          (ind=3)

 OUTPUTS
   Descr    int  descriptor in 16-bit integer (BUFR) form   (ind!=1)
   FXXYYY   int  descriptor in 6-digit readable form fxxyyy (ind!=2)
   F, X, Y  int  individual elements of descriptor          (ind!=3
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Converts a BUFR descriptor from one of:
    1. a 16-bit integer (as encoded in Section 3 of a BUFR message),
    2. a 6-digit descriptor suitable for printing (e.g. 301234) or
    3. individual descriptor elements F,X,Y (e.g. 3,1,234)
   to the other two forms. Which of these three forms to use as input
   is specified by the 'ind' argument, 1, 2 or 3; any other value will
   be silently ignored.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1) Manual on codes. International Codes, Vol 1.2, Part B - Binary Codes.
      2010 Edition, WMO-306, WMO, Geneva.
\end{Verbatim}
\section{BUFR/BUFRUTILS/ConvertMOtoEC}
\textsl{[ Subroutines ]}

\label{ch:robo5}
\label{ch:BUFR_BUFRUTILS_ConvertMOtoEC}
\index{unsorted!BUFRUTILS/ConvertMOtoEC}\index{Subroutines!BUFRUTILS/ConvertMOtoEC}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ConvertMOtoEC    (BUFRutils.f90)
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
  Convert expanded descriptors and decoded values from MetDB to ECMWF format

   CHARACTER (LEN=nn) :: pValues
   CHRACATER (LEN=80) :: cvalues(nv)
   INTEGER :: ExpDecr(nd), nExpDescr, nObs
   REAL    :: Values1(nv)
   REAL*8  :: Values2(nv)
   CALL DEBUFR ( ExpDescr, Values1, pValues, nExpDescr, nObs, ... )
   CALL DEBUFR ( ExpDescr, Values1, ... nExpDescr ...)
   CALL ConvertMOtoEC ( nExpDescr, ExpDescr, nObs, &
                        Values1, Values2, pValues, cValues )
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   nExpDescr int  No. of expanded descriptors
   ExpDescr  int  Array(nd) of expanded descriptors (16-bit format)
   nObs      int  Number of observations
   Values1   flt  Array(nv) of decoded numeric values
   pValues   chr  String of packed dcoded character values

 OUTPUTS
   nDescr    int  Updated no. of expanded descriptors
   ExpDescr  int  Array(nd) of updated expanded descriptors (fxxyyy format)
   Values2  dflt  Array(nv) of updated decoded numeric values
   cvalues   chr  Array(nv) of updated decoded character values
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   ConvertDescriptor
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Converts expanded descriptor list and decoded numeric and character values
   from MetDB BUFR library DEBUFR() interface, to equivalents compatible
   with those returned by ECMWF BUFREX() and BUSEL() routines (see Refs.)
    1) convert MetDB raw 16-bit descriptor values to fxxyyy format;
    for numeric data:
    2) extract the replication count from any replication operator
       descriptors (1xxyyy) and insert count into the Values array; replace
       the replication operator descriptor with a replication factor
       descriptor (03100y);
    3) remove any change operator descriptors (2xxyyy)
    4) Change MetDB missing data values (RMDFV) to ECMWF equivalent (RVIND);
    for character data:
    5) extract pointers from value array and unpack flat string to
       character array
   Hence for each replication, Values will lengthen by one and for each
   change, ExpDescr will shorten by one until there is 1-to-1 correspondance
   between ExpDescr and Values/cValues arrays.
   Note that for correctly expanded descriptors, there will be no sequence
   descriptors (3xxyyy), so these are not checked for.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1. Met Office (2011). Decoding and Encoding BUFR messages.
      MetDB Technote 1, Rev.4, Feb 2011 [dmtn1.html].
   2. Dragosavac, Milan (2009). BUFR User's Guide.
      ECMWF Operations Department Technical Note, July 2009.
\end{Verbatim}
\section{BUFR/BUFRUTILS/ExtractMOinfo}
\textsl{[ Subroutines ]}

\label{ch:robo6}
\label{ch:BUFR_BUFRUTILS_ExtractMOinfo}
\index{unsorted!BUFRUTILS/ExtractMOinfo}\index{Subroutines!BUFRUTILS/ExtractMOinfo}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ExtractMOinfo   (BUFRutils.f90)
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Extract information from MetDB BUFR Sections 0-5 (except encoded
   Section 4 data)

    CHARACTER (LEN=nnn) :: cBUF
    INTEGER :: Supp(9), Sec10(3), Sec1(40),
    INTEGER :: Sec2(4096), Sec3(4), Sec4(2), Sec5(2)
    INTEGER :: nDescr, Descr(nd)
    CALL ExtractMOinfo ( cBUF, Supp, Sec0, Sec1, Sec2, &
                         Sec3, Sec4, Sec5, nDescr, Descr )
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   cBUF    chr  BUFR message bit string (MetDB I/O interface)

 OUTPUTS
   Supp    int  Array(9)    for Supplimentary info
   Sec0    int  Array(3)    for Section 0 info
   Sec1    int  Array(40)   for Section 1 info
   Sec2    int  Array(4096) for Section 2 info
   Sec3    int  Array(4)    for Section 3 info
   Sec4    int  Array(2)    for Section 4 info
   Sec5    int  Array(2)    for Section 5 info
   nDecsr  int  No. of descriptors in Section 3
   Descr   int  Array(nd)   of  descriptors (fxxyyy format)
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   ConvertDescriptor
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Extracts BUFR Section 0-5 information (excep actual encoded Section 4
   data) from a BUFR message using the MetDB character string I/O interface.
   This routine, together with MetDB DEBUFR() provides the unexpanded and
   expanded descriptor lists compatible with ECMWF BUSEL() and Section
   header information returned by BUS123().
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1. Manual on Codes: International Codes, Part B & Part C.
      WMO-No. 306, World Meteorological Organisation, Geneva.
      http://www.wmo.int/pages/prog/www/WMOCodes/VolumeI2.html
   2. Met Office (2011). Decoding and Encoding BUFR messages.
      MetDB Technote 1, Rev.4, Feb 2011 [dmtn1.html].
   3. Dragosavac, Milan (2009). BUFR User's Guide.
      ECMWF Operations Department Technical Note, July 2009.
\end{Verbatim}
\section{BUFR/BUFRUTILS/ReplicationCount}
\textsl{[ Functions ]}

\label{ch:robo7}
\label{ch:BUFR_BUFRUTILS_ReplicationCount}
\index{unsorted!BUFRUTILS/ReplicationCount}\index{Functions!BUFRUTILS/ReplicationCount}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ReplicationCount
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Extract a replication count from list of expanded descriptors
   and decoded values for a given key descriptor

   INTEGER :: ExpDecr(nd), nDescr, KeyDescr
   REAL*8  :: Values(nv)
   CALL ReplicationCount ( ExpDescr, Vaues, KeyDescr )
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   ExpDescr  int  Array(nDescr) of expanded descriptors (fxxyyy format)
   Values   dflt  Array(nVals)  of decoded values corresponding 1-to-1
                  with decriptors in ExpDescr
   KeyDescr  int  Key descriptor (fxxyyy format)

 OUTPUTS
   ReplicationCount  int  Replication count value (fn return)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Get a replication count by searching for a Replication Count Factor
   descriptor in the expanded descriptor list which is followed by the key
   descriptor, and extract the replication count from the associated element
   of the decoded Values array.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1. Manual on Codes: International Codes, Part B & Part C.
      WMO-No. 306, World Meteorological Organisation, Geneva.
      http://www.wmo.int/pages/prog/www/WMOCodes/VolumeI2.html
\end{Verbatim}
\section{BUFR/GTSHDRS/GTShdrARH}
\textsl{[ Subroutines ]}

\label{ch:robo8}
\label{ch:BUFR_GTSHDRS_GTShdrARH}
\index{unsorted!GTSHDRS/GTShdrARH}\index{Subroutines!GTSHDRS/GTShdrARH}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   GTShdrARH    (gtshdrs.f90)
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Generate WMO Abbreviated Routing Header (ARH) sequence
   for GTS dissemination

   INTEGER            :: CSN, DateTime(6), Lat, Lon, lARH
   CHARACTER (LEN=6)  :: TTAAII
   CHARACTER (LEN=4)  :: CCCC
   CHARACTER (LEN=31) :: cARH
   CALL GTShdrARH ( CSN, TTAAII, Lat, Lon, CCCC, DateTime, cARH, lARH )
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   CSN       int  Channel (GTS bulletin) sequence number (001-999)
   TTAAII    chr  6-chr data ID (t1t2a1a2ii) Note that the a2 character
                  will be set by this routine from (Lat,Lon) info.
   Lat       int  Latitude  of data (-90  to +90 deg.)
   Lon       int  Longitude of data (-180 to +180 or 0 to 360 deg.)
   CCCC      chr  4-chr GTS source node ID (ICAO code) (cccc)
   DateTime  int  6-element date/time (yr,mon,day,hr,min,sec)

 OUTPUTS
   CSN       int  Incremented Channel (GTS bulletin) sequence number (001-999)
   cARH      chr  Character string of at least (31) for ARH sequence
   lARH      int  Length of ARH in bytes (normally 31)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Codes data routing header information into WMO/GTS standard
   31-byte abbreviated routing header (ARH) (see references) of the form:
     'sssrrriii'
   where:
     'sss' is a 10-byte message start sequence: 'SOH/CR/CR/LF/CSN/CR/CR/LF'
     'rrr' is the 18-byte routing header:       't1t2a1a2ii cccc YYGGgg'
     'iii' is a 3-byte data introducer iii:     'CR/CR/LF'.
   The channel sequence number (CSN) should be a sequential 3-digit
   integer cycling from 001 to 999, and is coded from the CSN value.
   Data ID (t1t2a1 and ii) is coded as given. Geographical area code
   (a2) is derived from given lat/lon of data. Source node (cccc) is
   the 4-chr ICAO code of the centre coding the data (e.g. 'EGRR' for
   Met Office, Exeter). Day of month (YY), hour (GG) and minute (gg)
   are coded from DateTime values. The ARH is returned as a plain ASCII
   string (containing non-printing control characters). The message
   should then be terminated with an end-of-message sequence, e.g. as
   generated with GTShdrEOM() to form a complete GTS bulletin. An optional
   IPH may be needed for transmission of files via TCP/IP protocol;
   this can be generated using GTShdrIPH().
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1) WMO (2009). Operational Procedures for the GTS, Attachment II-5,
      Data Designators T1T2A1A2ii in Abbreviated Headings, Table C3.
      WMO, Geneva, 4 November 2009.
   2) Nightingale, S. (2008). Exchange of data with the
      Met Office FROST message switch.
      FROST FTP Protocol Document, V2.1, 2 October 2008.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
   GTShdrIPH() - to generate a GTS IP Header
   GTShdrEOM() - to generate a GTS End-of-Message sequence
\end{Verbatim}
\section{BUFR/GTSHDRS/GTShdrCSN}
\textsl{[ Subroutines ]}

\label{ch:robo9}
\label{ch:BUFR_GTSHDRS_GTShdrCSN}
\index{unsorted!GTSHDRS/GTShdrCSN}\index{Subroutines!GTSHDRS/GTShdrCSN}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   GTShdrCSN   (gtshdrs.f90)
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Read or save a channel sequence number

    CHARACTER (LEN=100) :: csnfile
    INTEGER :: csn
    CHARACTER (LEN=1) :: rw = ['R'|'W']
    CALL GTShdrCSN ( csnfile, csn, rw )
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   CSNfile  chr  Channel sequence number file name
   CSN      int  Channel sequence number (001-999) (write)
   RorW     chr  'R' or 'r' for input or 'W' or 'w' for output

 OUTPUTS
   CSN      int  Channel sequence number (001-999) (read)

 ERRORS
   If the CSN file cannot be opened for read, or the CSN is not a valid
   integer, a default sequence initialisation CSN value will be returned as
   zero. Otherwise, CSN values read from the file or passed to this routine
   for write will always be returned in the range 001-999.
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   GTShdrUNT
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Reads (if RorW='R') or writes (if RorW='W') a channel sequence number
   (which should be in the range 001-999) from/to the given file. If the
   file name is blank, or the first character of RorW is not 'R' or 'W',
   nothing happens (RorW is case-insensitive).
   Warning messages are written to stdout if any I/O error occurs (the value
   of CSN is unchanged), but otherwise the action is silent unless the
   debug mode is enabled.
   The file name may include an absolute path, and should be accessible for
   read & write. The file should also be in a stable location so as to be
   available for subsequent program runs - don't use places such as /tmp or
   /var/tmp, etc.
   Note that GTShdrARH() will increment CSN (and keep it within the valid
   range 1-999) before coding into the ARH; this routine merely reads the
   value from the file and saves the given value back, unchanged (apart
   from ensuring that the value is within valid range).
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
   GTShdrARH
\end{Verbatim}
\section{BUFR/GTSHDRS/GTShdrEOM}
\textsl{[ Subroutines ]}

\label{ch:robo10}
\label{ch:BUFR_GTSHDRS_GTShdrEOM}
\index{unsorted!GTSHDRS/GTShdrEOM}\index{Subroutines!GTSHDRS/GTShdrEOM}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   GTShdrEOM   (gtshdrs.f90)

 SYNOPIS
   Generate WMO GTS end-of-message (EOM) sequence

   USE GTShdrsMod
   CHARACTER (LEN=4) :: cEOM
   INTEGER :: lEOM
   CALL GTShdrEOM ( cEOM, lEOM )

 INPUT
   NONE
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
   cEOM  chr  Character string of at least (4) for plain character EOM
   lEOM  int  Length of EOM in bytes (normally 4)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Generates WMO GTS 4-byte end-of-message sequence 'CR/CR/LF/ETX' used to
   terminate a WMO/GTS bulletin (such as BUFR or GRIB message with routing
   headers) according to WMO Format 00 (see Reference 1).
   The EOM is returned as a plain ASCII string (containing non-printing
   control chracters).
   The message should have been prefixed with an ARH (e.g. as generated
   using GTShdrARH()) and optionally by an IP leader (GTShdrIPH()) if
   intended for transmission over TCP/IP links.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1) Bridgeman, D. & Little, C. (2004). Exchange of data with the
      Met Office FROST message switch.
      FROST FTP Protocol Document, V1.0, 31 October 2004.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
   GTShdrARH() - to generate a GTS Abbreviated Routing Header
   GTShdrIPH() - to generate an IP Header for TCP/IP transmission
\end{Verbatim}
\section{BUFR/GTSHDRS/GTShdrIPH}
\textsl{[ Subroutines ]}

\label{ch:robo11}
\label{ch:BUFR_GTSHDRS_GTShdrIPH}
\index{unsorted!GTSHDRS/GTShdrIPH}\index{Subroutines!GTSHDRS/GTShdrIPH}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   GTShdrIPH   (gtshdrs.f90)

 SYNOPIS
   Generate IP start-of-message header (IPH) sequence

   USE GTShdrsMod
   CHARACTER (LEN=10) :: cIPH
   INTEGER :: Lenm, lIPH
   CALL GTShdrIPH ( Lenm, cIPH, lIPH )

 INPUT
   Lenm  int  Length of GTS bulletin in bytes (including ARH but not IPH)
              to set into IPH (0-99999989)
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
   cIPH  chr  Chracter string of at least (10) for IPH sequence
   lIPH  int  Length of IPH in bytes (normally 10)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Generates a 10-byte start-of-message header sequence for IP transmission
   protocols according to WMO Format 00 (see Reference 1).
   This header should be output immediately before the GTS bulletin
   (BUFR message plus ARH & start/end wrappers generated by GTShdrARH &
   GTShdrEOM).
   The length of the bulletin, plus the IP header itself, is set into
   the header. If Len is given as 0, this is assumed to be a dummy
   IP header, and 10 '0's are returned in IPH. This dummy IPH is used to
   terminate a file containing one or more bulletins intended for
   transmission using IP (GTS/RMDCN etc). The IPH sequence is returned
   as a plain ASCII string.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1) Nightingale, S. (2008). Exchange of data with the
      Met Office FROST message switch.
      FROST FTP Protocol Document, V2.1, 2 October 2008.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
   GTShdrARH() - to generate a GTS Abbreviated Routing Header
   GTShdrEOM() - to generate a GTS End-of-Message sequence
\end{Verbatim}
\section{BUFR/GTSHDRS/GTShdrs}
\textsl{[ Modules ]}

\label{ch:robo12}
\label{ch:BUFR_GTSHDRS_GTShdrs}
\index{unsorted!GTSHDRS/GTShdrs}\index{Modules!GTSHDRS/GTShdrs}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   GTShdrs    (gtshdrs.f90)
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Module defining fixed values & subroutines for generating WMO GTS/RMDCN
   routing headers, etc.

   USE GTShdrs
   INTEGER            :: CSN, DateTime(6), un
   CHARACTER (LEN=50) :: CSNfile
   CHARACTER (LEN=6)  :: TTAAII
   CHARACTER (LEN=4)  :: CCCC
   CHARACTER (LEN=10) :: cIPH
   CHARACTER (LEN=31) :: cARH
   CHARCATER (LEN=4)  :: cEOM
   INTEGER            :: Lat, Lon, lIPH, lARH, lEOM
   GTSHDR_DEBUG = .TRUE.  ! optionally enable debug mode
   CALL GTShdrIPH ( cIPH, lIPH )
   CALL GTShdrARH ( CSN, TTAAII, Lat, Lon, CCCC, DateTime, &
                    cARH, lARH )
   CALL GTShdrEOM ( cEOM, lEOM )
   CALL GTShdrCSN ( CSNfile, CSN, 'R'|'W' )
   un = GTShdrUNT ()
\end{Verbatim}
\textbf{USED BY:}\hspace{0.08in}\begin{Verbatim}
   BUFR or GRIB encoding applications requiring GTS headers
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   A 'naked' BUFR (or GRIB) "message" starts with the characters 'BUFR'
   (or 'GRIB') and terminates with '7777' (Ref.1). However, such a message
   cannot be transmitted over WMO GTS (or RMDCN) links wihtout some form
   of routing information. This is provided by appending a standard
   "Abbreviated Routing Header" (ARH) (Ref.2) and terminating with an
   "end-of-message" (EOM) sequence. A message with ARH & EOM wrappers
   is known as a "bulletin" and is the basic block of bytes transmitted
   over the GTS/RMDCN.
   Further, as protocols allow for more than one bulletin in a physical
   file, each bulletin is usually (though not universally, depending on
   local GTS node procedures) prefixed by a "Internet Protocol Header" (IPH)
   or leader sequence which contains the total bulletin length in bytes
   (including the IPH itself) and a data format identifier. The file is
   terminated with a dummy IPH after the last bulletin (Ref.3).
   This module provides routines to generate an IPH (actual or dummy), an
   ARH and an EOM sequence. The routines return these sequences of bytes
   as plain ASCII character strings (containing non-printing control
   characters) which can be output 'as-is' using a write routine such as
   METDB_CWRITE() from the MetDB BUFR library (Ref.4) or - with pre-packing
   to integers - with PBWRITE() from the ECMWF BUFR library (Ref.5).

 EXAMPLES
   1) Generate an ARH with CSN sequence cycling between runs

     USE GTShdrs
     INTEGER            :: CSN, DateTime(6)=(/2011,06,30,13,32,0/)
     CHARACTER (LEN=5)  :: TTAAII="ISX?14"
     CHARACTER (LEN=4)  :: CCCC="EGRR"
     CHARACTER (LEN=31) :: cARH
     CHARACTER (LEN=50) :: CSNfile = "/data/gwv/csn.dat"
     INTEGER            :: Lat=50, Lon=10
     INTEGER            :: BUFRunit, lARH
     GTSHDR_DEBUG = .TRUE.                    ! optionally enable debug mode
     CALL GTShdrCSN ( CSNfile, CSN, 'Read' )  ! read last used CSN
     CALL GTShdrARH ( CSN, TTAAII, Lat, Lon, CCCC, DateTime, &
                      cARH, lARH )            ! generate ARH
     CALL GTShdrCSN ( CSNfile, CSN, 'Write' ) ! save last CSN

   2) Write ARH to BUFR file using MetDB BUFR library

     INTEGER :: BUFRunit  ! from METDB_COPEN()
     CALL METDB_CWRITE ( BUFRunit, cARH(1:lARH), lARH )

   3) Write ARH to BUFR file using ECMWF BUFR library
      (pack bytes from chr to int first)

     INTEGER :: BUFRunit  ! from PBOPEN()
     INTEGER :: uARH(31), pARH(8), ierr
     DO i = 1, lARH
       uARH(i) = IACHAR(cARH(i:i))
     END DO
     CALL SBYTES  ( pARH, uARH, 0, 8, 0, lARH )
     CALL PBWRITE ( BUFRunit, pARH, lARH, ierr )
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1) Manual on the Global Telecommunications System.
      Vol.1, Part II. WMO, Geneva, 1986 (and updates)
   2) WMO (2009). Operational Procedures for the GTS, Attachment II-5,
      Data Designators T1T2A1A2ii in Abbreviated Headings, Table C3.
      WMO, Geneva, 4 November 2009.
   3) Nightingale, S. (2008). Exchange of data with the
      Met Office FROST message switch.
      FROST FTP Protocol Document, V2.1, 2 October 2008.
   4) Met Office (2011). Decoding and Encoding BUFR messages.
      MetDB Technote 1, Rev.4, February 2011 [dmtn1.html].
   5) Dragosavac, Milan (2009). BUFR User's Guide.
      ECMWF Operations Department Technical Note, July 2009.
\end{Verbatim}
\section{BUFR/GTSHDRS/GTShdrUNT}
\textsl{[ Functions ]}

\label{ch:robo13}
\label{ch:BUFR_GTSHDRS_GTShdrUNT}
\index{unsorted!GTSHDRS/GTShdrUNT}\index{Functions!GTSHDRS/GTShdrUNT}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   GTShdrUNT   (gtshdrs.f90)
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Obtain a free Fortran unit number

   USE GTShdrs
   INTEGER :: unit
   unit = GTShdrUNT()
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   None

 OUTPUTS
   GTShdrUNT   (funcn)  Unit number (10-999 or 0 if no free numbers)

 ERRORS
   If there are no free unit numbers in the range 10-999, then
   a warning message is written to stdout and 'unit' is returned
   with a value of zero.
\end{Verbatim}
\textbf{CALLED BY:}\hspace{0.08in}\begin{Verbatim}
   GTShdrCSN
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   This function returns the first available unit number larger than 10, but
   no larger than 999.
   If no available unit number is found, a warning message will be written
   to stdout, and the unit number will be returned as zero. This may be
   valid for most compilers, so if free, the file open may still work.
   Other compilers may give a file OPEN() 'invalid unit number' error.
\end{Verbatim}
\section{bufr2ropp/bufr2ropp}
\textsl{[ Modules ]}

\label{ch:robo14}
\label{ch:bufr2ropp_bufr2ropp}
\index{unsorted!bufr2ropp}\index{Modules!bufr2ropp}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   bufr2ropp    (bufr2ropp_mod.f90)
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Module defining fixed values & common subroutines/functions for the
   bufr2ropp main program (ECMWF or MetDB versions)

   USE bufr2ropp
\end{Verbatim}
\textbf{USED BY:}\hspace{0.08in}\begin{Verbatim}
   bufr2ropp  (bufr2ropp_ec or bufr2ropp_mo)
\end{Verbatim}
\subsection{bufr2ropp/ConvertBUFRtoROPP}
\textsl{[ bufr2ropp ]}
\textsl{[ Subroutines ]}

\label{ch:robo15}
\label{ch:bufr2ropp_ConvertBUFRtoROPP}
\index{unsorted!ConvertBUFRtoROPP}\index{Subroutines!ConvertBUFRtoROPP}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ConvertBUFRtoROPP
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Convert BUFR data to ROPP specification

    USE ropp_io_types
    USE bufr2ropp
    TYPE (ROprof) ROdata
    REAL*8  :: values(nv)
    INTEGER :: nfreq, ierr
    CALL ConvertBUFRtoROPP ( values, nfreq, ROdata, ierr )
   where
    ne is the number of elements (data items from BUFR)
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   Values  dflt  Array of values from BUFR decoder
   NFreq    int  No. of frequency sets in BUFR (1 or 3)
   ROdata  dtyp  ROPP data - derived type

 OUTPUTS
   ROdata  dtyp  ROPP data - derived type, updated
   ierr     int  Return code: 0=OK
                              1=sync error (mis-matched replic. factor)
                              2=wrong frequency value
                              3=wrong vertical significance code
\end{Verbatim}
\textbf{USES:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_types  - ROPP file I/O support
   ropp_io        - i/o routines
   geodesy        - geodesy routines
   messages       - messages interface
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   ConvertCodes
   ropp_io_occid
   geometric2geopotential
   messages
   message_get_routine
   message_set_routine
\end{Verbatim}
\textbf{CALLED BY:}\hspace{0.08in}\begin{Verbatim}
   bufr2ropp
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Converts decoded BUFR plain array data to ROPP derived type units etc.
   This procedure is mostly scaling and/or range changing (e.g. Pa to hPa).
   This routine also performs gross error checking, so that if data is not
   valid (normally indicated by the BUFR 'missing data' flag value) that data
   value is left as default "missing" in the ROPP structure.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1) ROPP User Guide - Part I
      SAF/ROM/METO/UG/ROPP/002
   2) WMO FM94 (BUFR) Specification for ROM SAF Processed Radio
      Occultation Data. SAF/ROM/METO/FMT/BUFR/001
\end{Verbatim}
\subsection{bufr2ropp/GetOptions}
\textsl{[ bufr2ropp ]}
\textsl{[ Subroutines ]}

\label{ch:robo16}
\label{ch:bufr2ropp_GetOptions}
\index{unsorted!GetOptions}\index{Subroutines!GetOptions}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   GetOptions
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Get command line information & options or set defaults

    USE bufr2ropp
    CHARACTER (LEN=100), DIMENSION(:), ALLOCATABLE :: BUFRdsn
    CHARACTER (LEN=100) :: roppdsn
    INTEGER :: nfiles, fMsgToDecode, nMsgToDecode
    LOGICAL :: multi, newfile
    nfiles=IARGC()
    ALLOCATE ( bufrdsn(nfiles) )
    CALL getoptions ( bufrdsn, nfiles, roppdsn, &
                      multi, newfile, fMsgToDecode, nMsgToDecode )
   On the command line:
    >  bufr2ropp bufr_file [...bufr_file...] [-o ropp_file]
                           [-m] [-a]   [-f first] [-n number]
                           [-d] [-h|?] [-v]
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   None

 OUTPUTS
   BUFRdsn       chr  BUFR input file name(s) (required)
   nfiles        int  No. of BUFR input files
   ROPPdsn       chr  ROPP output file name (optional)
   multi         log  Multifile output (netCDF only) (default: single files)
   newfile       log  .T. to start a new file, else append (default: new)
   fMsgToDecode  int  First  RO message  to decode (default: 1)
   nMsgToDecode  int  No. of RO messages to decode (default: all)
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   Usage
   message
   GETARG
   IARGC
\end{Verbatim}
\textbf{CALLED BY:}\hspace{0.08in}\begin{Verbatim}
   bufr2ropp
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Provides a command line interface for the BUFR-to-ROPP
   decoder application. See comments for main program bufr2ropp
   for the command line details.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
   bufr2ropp(1)
\end{Verbatim}
\subsection{bufr2ropp/Usage}
\textsl{[ bufr2ropp ]}
\textsl{[ Subroutines ]}

\label{ch:robo17}
\label{ch:bufr2ropp_Usage}
\index{unsorted!Usage}\index{Subroutines!Usage}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   Usage

 SYNOPIS
   USE bufr2ropp
   CALL Usage()
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   None

 OUTPUTS
   Summary usage text to stdout
\end{Verbatim}
\textbf{CALLED BY:}\hspace{0.08in}\begin{Verbatim}
   GetOptions
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Prints a summary of program usage (help) to stdout.
\end{Verbatim}
\section{common/ropp\_io\_version}
\textsl{[ Functions ]}

\label{ch:robo18}
\label{ch:common_ropp_io_version}
\index{unsorted!ropp\_io\_version}\index{Functions!ropp\_io\_version}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_version
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Return ROPP_IO version ID string

   USE ropp_io
   version = ropp_io_version()
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   This function returns the (common) version string for the ROPP_IO
   module. By default, this function should be called by all ROPP_IO
   tools to display a version ID when the '-v' command-line switch is
   used.
\end{Verbatim}
\section{Datatypes/BGrange}
\textsl{[ Structures ]}

\label{ch:robo19}
\label{ch:Datatypes_BGrange}
\index{unsorted!BGrange}\index{Structures!BGrange}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    BGrange - A sub-structure of the BGtype structure, setting valid ranges.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE BGrange
    INTEGER,  DIMENSION(2) :: year     = (/1995,    2099/)
    INTEGER,  DIMENSION(2) :: month    = (/  01,      12/)
    INTEGER,  DIMENSION(2) :: day      = (/  01,      31/)
    INTEGER,  DIMENSION(2) :: hour     = (/  00,      23/)
    INTEGER,  DIMENSION(2) :: minute   = (/  00,      59/)
    REAL(wp), DIMENSION(2) :: fcperiod = (/  00.0_wp, 24.0_wp/)
  END TYPE BGrange
\end{Verbatim}
\section{Datatypes/BGtype}
\textsl{[ Structures ]}

\label{ch:robo20}
\label{ch:Datatypes_BGtype}
\index{unsorted!BGtype}\index{Structures!BGtype}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    BGunits - A sub-structure of the ROprof structure, describing background (as used
              in the retrieval) meta data.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE BGtype
    CHARACTER(len = 20) :: source   = 'NONE' ! Source of b/g profile
    INTEGER             :: year     = 9999   ! VT year   of b/g
    INTEGER             :: month    =   99   ! VT month  of b/g
    INTEGER             :: day      =   99   ! VT day    of b/g
    INTEGER             :: hour     =   99   ! VT hour   of b/g
    INTEGER             :: minute   =   99   ! VT minute of b/g
    REAL(wp)            :: fcperiod =  999.9 ! F/c period (hrs)
    TYPE(BGunits)       :: units
    TYPE(BGrange)       :: range
  END TYPE BGtype
\end{Verbatim}
\section{Datatypes/BGunits}
\textsl{[ Structures ]}

\label{ch:robo21}
\label{ch:Datatypes_BGunits}
\index{unsorted!BGunits}\index{Structures!BGunits}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    BGunits - A sub-structure of the BGtype structure, defining units.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE BGunits
    CHARACTER(len = 64) :: year     = "years"
    CHARACTER(len = 64) :: month    = "months"
    CHARACTER(len = 64) :: day      = "days"
    CHARACTER(len = 64) :: hour     = "hours"
    CHARACTER(len = 64) :: minute   = "minutes"
    CHARACTER(len = 64) :: fcPeriod = "hours"
  END TYPE BGunits
\end{Verbatim}
\section{Datatypes/DT7range}
\textsl{[ Structures ]}

\label{ch:robo22}
\label{ch:Datatypes_DT7range}
\index{unsorted!DT7range}\index{Structures!DT7range}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    DT7range - A sub-structure of the DT7type structure, setting valid ranges.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE DT7range
    INTEGER, DIMENSION(2) :: year   = (/1995, 2099/)
    INTEGER, DIMENSION(2) :: month  = (/  01,   12/)
    INTEGER, DIMENSION(2) :: day    = (/  01,   31/)
    INTEGER, DIMENSION(2) :: hour   = (/  00,   23/)
    INTEGER, DIMENSION(2) :: minute = (/  00,   59/)
    INTEGER, DIMENSION(2) :: second = (/  00,   59/)
    INTEGER, DIMENSION(2) :: msec   = (/  00,  999/)
  END TYPE DT7range
\end{Verbatim}
\section{Datatypes/DT7type}
\textsl{[ Structures ]}

\label{ch:robo23}
\label{ch:Datatypes_DT7type}
\index{unsorted!DT7type}\index{Structures!DT7type}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    DT7types - A sub-structure of the ROprofs structure for date information.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE DT7type
    INTEGER        :: year   = 9999
    INTEGER        :: month  =   99
    INTEGER        :: day    =   99
    INTEGER        :: hour   =   99
    INTEGER        :: minute =   99
    INTEGER        :: second =   99
    INTEGER        :: msec   = 9999
    TYPE(DT7units) :: units
    TYPE(DT7range) :: range
  END TYPE DT7type
\end{Verbatim}
\section{Datatypes/DT7units}
\textsl{[ Structures ]}

\label{ch:robo24}
\label{ch:Datatypes_DT7units}
\index{unsorted!DT7units}\index{Structures!DT7units}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    DT7units - A sub-structure of the DT7type structure, defining units.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE DT7units
    CHARACTER(len = 64) :: year     = "years"
    CHARACTER(len = 64) :: month    = "months"
    CHARACTER(len = 64) :: day      = "days"
    CHARACTER(len = 64) :: hour     = "hours"
    CHARACTER(len = 64) :: minute   = "minutes"
    CHARACTER(len = 64) :: second   = "seconds"
    CHARACTER(len = 64) :: msec     = "milliseconds"
  END TYPE DT7units
\end{Verbatim}
\section{Datatypes/GEOrange}
\textsl{[ Structures ]}

\label{ch:robo25}
\label{ch:Datatypes_GEOrange}
\index{unsorted!GEOrange}\index{Structures!GEOrange}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    GEOrange - A sub-structure of the GEOtype structure, setting valid ranges.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE GEOrange
    REAL(wp), DIMENSION(2) :: time_offset = (/0.0_wp,    239.999_wp/)
    REAL(wp), DIMENSION(2) :: lat         = (/ -90.0_wp,  90.0_wp/)
    REAL(wp), DIMENSION(2) :: lon         = (/-180.0_wp, 180.0_wp/)
    REAL(wp), DIMENSION(2) :: roc         = (/ 6.2e6_wp, 6.6e6_wp/)
    REAL(wp), DIMENSION(2) :: r_coc       = (/-5.0e4_wp, 5.0e4_wp/)
    REAL(wp), DIMENSION(2) :: azimuth     = (/   0.0_wp, 360.0_wp/)
    REAL(wp), DIMENSION(2) :: undulation  = (/-150.0_wp, 150.0_wp/)
  END TYPE GEOrange
\end{Verbatim}
\section{Datatypes/GEOref}
\textsl{[ Structures ]}

\label{ch:robo26}
\label{ch:Datatypes_GEOref}
\index{unsorted!GEOref}\index{Structures!GEOref}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    GEOref - A sub-structure of the GEOtype structure, defining the reference frame
             for the centre of curvature.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE GEOref
    CHARACTER(len = 3)     :: r_coc = 'ECF'
  END TYPE GEOref
\end{Verbatim}
\section{Datatypes/GEOtype}
\textsl{[ Structures ]}

\label{ch:robo27}
\label{ch:Datatypes_GEOtype}
\index{unsorted!GEOtype}\index{Structures!GEOtype}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    GEOtype - A sub-structure of the ROprof structure, describing the georeferencing
              a given profile.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE GEOtype
    REAL(wp)               :: time_offset = ropp_MDFV ! Time since start (s)
    REAL(wp)               :: lat         = ropp_MDFV ! Latitude  (deg)
    REAL(wp)               :: lon         = ropp_MDFV ! Longitude (deg)
    REAL(wp)               :: roc         = ropp_MDFV ! RoC value (m)
    REAL(wp), DIMENSION(3) :: r_coc       = ropp_MDFV ! RoC offset X,Y,Z vector (m)
    REAL(wp)               :: azimuth     = ropp_MDFV ! GNSS->LEO line of sight angle (degT)
    REAL(wp)               :: undulation  = ropp_MDFV ! Geoid undulation (EGM96-WGS84) (m)
    TYPE(GEOunits)         :: units
    TYPE(GEOrange)         :: range
    TYPE(GEOref)           :: reference_frame
  END TYPE GEOtype
\end{Verbatim}
\section{Datatypes/GEOunits}
\textsl{[ Structures ]}

\label{ch:robo28}
\label{ch:Datatypes_GEOunits}
\index{unsorted!GEOunits}\index{Structures!GEOunits}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    GEOunits - A sub-structure of the GEOtype structure, setting units.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE GEOunits
    CHARACTER(len = 64) :: time_offset = "seconds"
    CHARACTER(len = 64) :: lat         = "degrees_north"
    CHARACTER(len = 64) :: lon         = "degrees_east"
    CHARACTER(len = 64) :: roc         = "metres"
    CHARACTER(len = 64) :: r_coc       = "metres"
    CHARACTER(len = 64) :: azimuth     = "degrees_T"
    CHARACTER(len = 64) :: undulation  = "metres"
  END TYPE GEOunits
\end{Verbatim}
\section{Datatypes/isroppinrange}
\textsl{[ Functions ]}

\label{ch:robo29}
\label{ch:Datatypes_isroppinrange}
\index{unsorted!isroppinrange}\index{Functions!isroppinrange}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    isroppinrange - Check elements of a data structure to be in a valid
                     range.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    true_or_not = isroppinrange(<data>)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This function checks if a given data item is within a valid range; it
    compliments the isinrange() function from the ropp_utils package to
    add data types used within ropp_io. As the latter carry their own
    valid_range information as part of their structure, no valid range needs
    to be specified.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    <data>       Data to be checked; currently limited to type(DT7type).
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    true_or_not  .true. if <data> is within the valid_range;
                 .false. otherwise.
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
    isinrange   from ropp_utils library
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    In the current version of ropp_io, isroppinrange only provides
    range checking for the DT7 data type, i.e. for dates and times.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    DT7type
\end{Verbatim}
\section{Datatypes/L1arange}
\textsl{[ Structures ]}

\label{ch:robo30}
\label{ch:Datatypes_L1arange}
\index{unsorted!L1arange}\index{Structures!L1arange}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L1arange - A sub-structure of the L1atype structure, setting valid ranges.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L1arange
    REAL(wp), DIMENSION(2) :: dtime      = (/   -1.0_wp, 239.999_wp/)
    REAL(wp), DIMENSION(2) :: snr        = (/    0.0_wp, 50000.0_wp/)
    REAL(wp), DIMENSION(2) :: phase      = (/ -1.0e6_wp,   1.0e6_wp/)
    REAL(wp), DIMENSION(2) :: r_gns      = (/-43.0e6_wp,  43.0e6_wp/)
    REAL(wp), DIMENSION(2) :: v_gns      = (/ -1.0e4_wp,   1.0e4_wp/)
    REAL(wp), DIMENSION(2) :: r_leo      = (/-10.0e6_wp,  10.0e6_wp/)
    REAL(wp), DIMENSION(2) :: v_leo      = (/ -1.0e4_wp,   1.0e4_wp/)
    REAL(wp), DIMENSION(2) :: phase_qual = (/    0.0_wp,   100.0_wp/)
  END TYPE L1arange
\end{Verbatim}
\section{Datatypes/L1aref}
\textsl{[ Structures ]}

\label{ch:robo31}
\label{ch:Datatypes_L1aref}
\index{unsorted!L1aref}\index{Structures!L1aref}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L1aref - A sub-structure of the L1atype structure, defining the reference frame
             for POD data.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L1aref
    CHARACTER(len = 3) :: r_gns = "ECF"
    CHARACTER(len = 3) :: v_gns = "ECI"
    CHARACTER(len = 3) :: r_leo = "ECF"
    CHARACTER(len = 3) :: v_leo = "ECI"
  END TYPE L1aref
\end{Verbatim}
\section{Datatypes/L1atype}
\textsl{[ Structures ]}

\label{ch:robo32}
\label{ch:Datatypes_L1atype}
\index{unsorted!L1atype}\index{Structures!L1atype}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L1atype - A sub-structure of the ROprof structure, containing amplitude, phase and
              POD data.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L1atype
    INTEGER                           :: Npoints    = 0       ! No. of samples in L1a profile
    LOGICAL                           :: Missing    = .TRUE.  ! No valid data if .T.
    REAL(wp), DIMENSION(:),   POINTER :: dtime      => null() ! Time since start (s)
    REAL(wp), DIMENSION(:),   POINTER :: snr_L1ca   => null() ! Signal-to-noise ratio - L1 (V/V)
    REAL(wp), DIMENSION(:),   POINTER :: snr_L1p    => null() ! Signal-to-noise ratio - L1 (V/V)
    REAL(wp), DIMENSION(:),   POINTER :: snr_L2p    => null() ! Signal-to-noise ratio - L1 (V/V)
    REAL(wp), DIMENSION(:),   POINTER :: phase_L1   => null() ! Excess phase   - L1 (m)
    REAL(wp), DIMENSION(:),   POINTER :: phase_L2   => null() ! Excess phase   - L2 (m)
    REAL(wp), DIMENSION(:,:), POINTER :: r_gns      => null() ! GNSS position (m)
    REAL(wp), DIMENSION(:,:), POINTER :: v_gns      => null() ! GNSS velocity (m/s)
    REAL(wp), DIMENSION(:,:), POINTER :: r_leo      => null() ! LEO  position (m)
    REAL(wp), DIMENSION(:,:), POINTER :: v_leo      => null() ! LEO velocity  (m/s)
    REAL(wp), DIMENSION(:),   POINTER :: phase_qual => null() ! Quality value (%)
    TYPE(L1aunits)                    :: units
    TYPE(L1arange)                    :: range
    TYPE(L1aref)                      :: reference_frame
  END TYPE L1atype
\end{Verbatim}
\section{Datatypes/L1aunits}
\textsl{[ Structures ]}

\label{ch:robo33}
\label{ch:Datatypes_L1aunits}
\index{unsorted!L1aunits}\index{Structures!L1aunits}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L1aunits - A sub-structure of the L1atype structure, defining units.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L1aunits
    CHARACTER(len = 64) :: dtime      = "seconds"
    CHARACTER(len = 64) :: snr        = "volt / volt"
    CHARACTER(len = 64) :: phase      = "metres"
    CHARACTER(len = 64) :: r_gns      = "metres"
    CHARACTER(len = 64) :: v_gns      = "metres / seconds"
    CHARACTER(len = 64) :: r_leo      = "metres"
    CHARACTER(len = 64) :: v_leo      = "metres / seconds"
    CHARACTER(len = 64) :: phase_qual = "percent"
  END TYPE L1aunits
\end{Verbatim}
\section{Datatypes/L1brange}
\textsl{[ Structures ]}

\label{ch:robo34}
\label{ch:Datatypes_L1brange}
\index{unsorted!L1brange}\index{Structures!L1brange}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L1brange - A sub-structure of the L1btype structure, setting valid ranges.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L1brange
    REAL(wp), DIMENSION(2)          :: lat_tp          = (/ -90.0_wp,   90.0_wp/)
    REAL(wp), DIMENSION(2)          :: lon_tp          = (/-180.0_wp,  180.0_wp/)
    REAL(wp), DIMENSION(2)          :: azimuth_tp      = (/   0.0_wp,  360.0_wp/)
    REAL(wp), DIMENSION(2)          :: impact          = (/   6.2e6_wp,  6.6e6_wp/)
    REAL(wp), DIMENSION(2)          :: bangle          = (/  -0.001_wp,   0.1_wp/)
    REAL(wp), DIMENSION(2)          :: bangle_sigma    = (/   0.0_wp,    0.01_wp/)
    REAL(wp), DIMENSION(2)          :: bangle_qual     = (/   0.0_wp,  100.0_wp/)
  END TYPE L1brange
\end{Verbatim}
\section{Datatypes/L1bType}
\textsl{[ Structures ]}

\label{ch:robo35}
\label{ch:Datatypes_L1bType}
\index{unsorted!L1bType}\index{Structures!L1bType}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L1btype - A sub-structure of the ROprof structure, containing bending angle and
              impact parameter data.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L1btype
    INTEGER                         :: Npoints          = 0       ! No. of samples in L1b profile
    LOGICAL                         :: Missing          = .TRUE.  ! No valid data if .T.
    REAL(wp), DIMENSION(:), POINTER :: lat_tp           => null() ! Latitude  (deg)
    REAL(wp), DIMENSION(:), POINTER :: lon_tp           => null() ! Longitude (deg)
    REAL(wp), DIMENSION(:), POINTER :: azimuth_tp       => null() ! GNSS->LEO line of sight angle (degT)
    REAL(wp), DIMENSION(:), POINTER :: impact_L1        => null() ! Impact param   - L1   (m)
    REAL(wp), DIMENSION(:), POINTER :: impact_L2        => null() ! Impact param   - L2   (m)
    REAL(wp), DIMENSION(:), POINTER :: impact           => null() ! Impact param   - corr (m)
    REAL(wp), DIMENSION(:), POINTER :: impact_Opt       => null() ! Impact param   - opt  (m)
    REAL(wp), DIMENSION(:), POINTER :: bangle_L1        => null() ! Bending angle  - L1   (rad)
    REAL(wp), DIMENSION(:), POINTER :: bangle_L2        => null() ! Bending angle  - L2   (rad)
    REAL(wp), DIMENSION(:), POINTER :: bangle           => null() ! Bending angle  - corr (rad)
    REAL(wp), DIMENSION(:), POINTER :: bangle_Opt       => null() ! Bending angle  - opt  (rad)
    REAL(wp), DIMENSION(:), POINTER :: bangle_L1_sigma  => null() ! Error in BA    - L1   (rad)
    REAL(wp), DIMENSION(:), POINTER :: bangle_L2_sigma  => null() ! Error in BA    - L2   (rad)
    REAL(wp), DIMENSION(:), POINTER :: bangle_sigma     => null() ! Error in BA    - corr (rad)
    REAL(wp), DIMENSION(:), POINTER :: bangle_Opt_sigma => null() ! Error in BA    - opt   (rad)
    REAL(wp), DIMENSION(:), POINTER :: bangle_L1_qual   => null() ! Quality values - L1   (%)
    REAL(wp), DIMENSION(:), POINTER :: bangle_L2_qual   => null() ! Quality values - L2   (%)
    REAL(wp), DIMENSION(:), POINTER :: bangle_qual      => null() ! Quality values - corr (%)
    REAL(wp), DIMENSION(:), POINTER :: bangle_Opt_qual  => null() ! Quality values - opt  (%)
    TYPE(L1bunits)                  :: units
    TYPE(L1brange)                  :: range
  END TYPE L1btype
\end{Verbatim}
\section{Datatypes/L1bunits}
\textsl{[ Structures ]}

\label{ch:robo36}
\label{ch:Datatypes_L1bunits}
\index{unsorted!L1bunits}\index{Structures!L1bunits}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L1bunits - A sub-structure of the L1btype structure, defining units.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L1bunits
    CHARACTER(len = 64)             :: lat_tp       = "degrees_north"
    CHARACTER(len = 64)             :: lon_tp       = "degrees_east"
    CHARACTER(len = 64)             :: azimuth_tp   = "degrees"
    CHARACTER(len = 64)             :: impact       = "metres"
    CHARACTER(len = 64)             :: bangle       = "radians"
    CHARACTER(len = 64)             :: bangle_sigma = "radians"
    CHARACTER(len = 64)             :: bangle_qual  = "percent"
  END TYPE L1bunits
\end{Verbatim}
\section{Datatypes/L2arange}
\textsl{[ Structures ]}

\label{ch:robo37}
\label{ch:Datatypes_L2arange}
\index{unsorted!L2arange}\index{Structures!L2arange}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L2arange - A sub-structure of the L2atype structure, setting valid ranges.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L2arange
    REAL(wp), DIMENSION(2)          :: alt_refrac     = (/-1.0e3_wp, 1.0e5_wp/)
    REAL(wp), DIMENSION(2)          :: geop_refrac    = (/-1.0e3_wp, 1.0e5_wp/)
    REAL(wp), DIMENSION(2)          :: refrac         = (/ 0.0_wp, 500.0_wp/)
    REAL(wp), DIMENSION(2)          :: refrac_sigma   = (/ 0.0_wp,  50.0_wp/)
    REAL(wp), DIMENSION(2)          :: refrac_qual    = (/ 0.0_wp, 100.0_wp/)
    REAL(wp), DIMENSION(2)          :: dry_temp       = (/150.0_wp, 350.0_wp/)
    REAL(wp), DIMENSION(2)          :: dry_temp_sigma = (/ 0.0_wp,  50.0_wp/)
    REAL(wp), DIMENSION(2)          :: dry_temp_qual  = (/ 0.0_wp, 100.0_wp/)
  END TYPE L2arange
\end{Verbatim}
\section{Datatypes/L2atype}
\textsl{[ Structures ]}

\label{ch:robo38}
\label{ch:Datatypes_L2atype}
\index{unsorted!L2atype}\index{Structures!L2atype}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L2atype - A sub-structure of the ROprof structure, containing refractivity, 
              dry temperature, altitude and geopotential height data.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L2atype
    INTEGER                         :: Npoints        = 0       ! No. of samples in L2a profile
    LOGICAL                         :: Missing        = .TRUE.  ! No valid data if .T.
    REAL(wp), DIMENSION(:), POINTER :: alt_refrac     => null() ! Geometric height (m)
    REAL(wp), DIMENSION(:), POINTER :: geop_refrac    => null() ! Geopotential height (m)
    REAL(wp), DIMENSION(:), POINTER :: refrac         => null() ! Refractivity (N-units)
    REAL(wp), DIMENSION(:), POINTER :: refrac_sigma   => null() ! Est. error in refractivity (N-units)
    REAL(wp), DIMENSION(:), POINTER :: refrac_qual    => null() ! Quality value - refrac (%)
    REAL(wp), DIMENSION(:), POINTER :: dry_temp       => null() ! Dry temperature (K)
    REAL(wp), DIMENSION(:), POINTER :: dry_temp_sigma => null() ! Est. error in dry temperature (K)
    REAL(wp), DIMENSION(:), POINTER :: dry_temp_qual  => null() ! Quality value - dry temp (%)
    TYPE(L2aunits)                  :: units
    TYPE(L2arange)                  :: range
  END TYPE L2atype
\end{Verbatim}
\section{Datatypes/L2aunits}
\textsl{[ Structures ]}

\label{ch:robo39}
\label{ch:Datatypes_L2aunits}
\index{unsorted!L2aunits}\index{Structures!L2aunits}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L2aunits - A sub-structure of the L2atype structure, defining units.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L2aunits
    CHARACTER(len = 64)             :: alt_refrac     = "metres"
    CHARACTER(len = 64)             :: geop_refrac    = "geopotential metres"
    CHARACTER(len = 64)             :: refrac         = "N-units"
    CHARACTER(len = 64)             :: refrac_sigma   = "N-units"
    CHARACTER(len = 64)             :: refrac_qual    = "percent"
    CHARACTER(len = 64)             :: dry_temp       = "kelvin"
    CHARACTER(len = 64)             :: dry_temp_sigma = "kelvin"
    CHARACTER(len = 64)             :: dry_temp_qual  = "percent"
  END TYPE L2aunits
\end{Verbatim}
\section{Datatypes/L2brange}
\textsl{[ Structures ]}

\label{ch:robo40}
\label{ch:Datatypes_L2brange}
\index{unsorted!L2brange}\index{Structures!L2brange}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L2brange - A sub-structure of the L2btype structure, setting valid ranges.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L2brange
    REAL(wp), DIMENSION(2)          :: geop         = (/ -1.0e3_wp,   1.0e5_wp/)
    REAL(wp), DIMENSION(2)          :: geop_sigma   = (/  0.0_wp,   500.0_wp/)
    REAL(wp), DIMENSION(2)          :: press        = (/  0.0001_wp, 1100.0_wp/)
    REAL(wp), DIMENSION(2)          :: press_sigma  = (/  0.0_wp,     5.0_wp/)
    REAL(wp), DIMENSION(2)          :: temp         = (/150.0_wp,   350.0_wp/)
    REAL(wp), DIMENSION(2)          :: temp_sigma   = (/  0.0_wp,     5.0_wp/)
    REAL(wp), DIMENSION(2)          :: shum         = (/  0.0_wp,    50.0_wp/)
    REAL(wp), DIMENSION(2)          :: shum_sigma   = (/  0.0_wp,     5.0_wp/)
    REAL(wp), DIMENSION(2)          :: meteo_qual   = (/  0.0_wp,   100.0_wp/)
  END TYPE L2brange
\end{Verbatim}
\section{Datatypes/L2btype}
\textsl{[ Structures ]}

\label{ch:robo41}
\label{ch:Datatypes_L2btype}
\index{unsorted!L2btype}\index{Structures!L2btype}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L2btype - A sub-structure of the ROprof structure, containing meteorological (i.e.
              temperature, pressure, (specific) humidity and geopotential height data.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L2btype
    INTEGER                         :: Npoints     = 0       ! No. of samples in L2b profile
    LOGICAL                         :: Missing     = .TRUE.  ! No valid data if .T.
    REAL(wp), DIMENSION(:), POINTER :: geop        => null() ! Geopotential height (m)
    REAL(wp), DIMENSION(:), POINTER :: geop_sigma  => null() ! Est. Error in geopotential height (m)
    REAL(wp), DIMENSION(:), POINTER :: press       => null() ! Pressure (hPa)
    REAL(wp), DIMENSION(:), POINTER :: press_sigma => null() ! Est. Error in pressure (hPa)
    REAL(wp), DIMENSION(:), POINTER :: temp        => null() ! Temperature (K)
    REAL(wp), DIMENSION(:), POINTER :: temp_sigma  => null() ! Est. error in temperature (K)
    REAL(wp), DIMENSION(:), POINTER :: shum        => null() ! Specific humidity (g/Kg)
    REAL(wp), DIMENSION(:), POINTER :: shum_sigma  => null() ! Est. error in SH  (g/Kg)
    REAL(wp), DIMENSION(:), POINTER :: meteo_qual  => null() ! Quality value (%)
    TYPE(L2bunits)                  :: units
    TYPE(L2brange)                  :: range
  END TYPE L2btype
\end{Verbatim}
\section{Datatypes/L2btype\_2d}
\textsl{[ Structures ]}

\label{ch:robo42}
\label{ch:Datatypes_L2btype_2d}
\index{unsorted!L2btype\_2d}\index{Structures!L2btype\_2d}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L2btype_2d - A sub-structure of the ROprof structure, containing meteorological (i.e.
                 temperature, pressure, (specific) humidity and geopotential height data.
                 Two-dimensional meteorological data version.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L2btype_2d
    INTEGER                           :: Npoints     = 0       ! No. of samples in L2b profile
    LOGICAL                           :: Missing    = .TRUE.   ! No valid data if .T.
    INTEGER                           :: Nhoriz      = 0       ! No. of horizontal points in L2b
    REAL(wp), DIMENSION(:,:), POINTER :: geop        => null() ! Geopotential height (m)
    REAL(wp), DIMENSION(:,:), POINTER :: geop_sigma  => null() ! Est. Error in geopot height (m)
    REAL(wp), DIMENSION(:,:), POINTER :: press       => null() ! Pressure (hPa)
    REAL(wp), DIMENSION(:,:), POINTER :: press_sigma => null() ! Est. Error in pressure (hPa)
    REAL(wp), DIMENSION(:,:), POINTER :: temp        => null() ! Temperature (K)
    REAL(wp), DIMENSION(:,:), POINTER :: temp_sigma  => null() ! Est. error in temperature (K)
    REAL(wp), DIMENSION(:,:), POINTER :: shum        => null() ! Specific humidity (g/Kg)
    REAL(wp), DIMENSION(:,:), POINTER :: shum_sigma  => null() ! Est. error in SH  (g/Kg)
    REAL(wp), DIMENSION(:,:), POINTER :: meteo_qual  => null() ! Quality value (%)
    TYPE(L2bunits)                    :: units
    TYPE(L2brange)                    :: range
  END TYPE L2btype_2d
\end{Verbatim}
\section{Datatypes/L2bunits}
\textsl{[ Structures ]}

\label{ch:robo43}
\label{ch:Datatypes_L2bunits}
\index{unsorted!L2bunits}\index{Structures!L2bunits}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L2bunits - A sub-structure of the L2btype structure, defining units.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L2bunits
    CHARACTER(len = 64)             :: geop         = "geopotential metres"
    CHARACTER(len = 64)             :: geop_sigma   = "geopotential metres"
    CHARACTER(len = 64)             :: press        = "hPa"
    CHARACTER(len = 64)             :: press_sigma  = "hPa"
    CHARACTER(len = 64)             :: temp         = "kelvin"
    CHARACTER(len = 64)             :: temp_sigma   = "kelvin"
    CHARACTER(len = 64)             :: shum         = "gram / kilogram"
    CHARACTER(len = 64)             :: shum_sigma   = "gram / kilogram"
    CHARACTER(len = 64)             :: meteo_qual   = "percent"
  END TYPE L2bunits
\end{Verbatim}
\section{Datatypes/L2crange}
\textsl{[ Structures ]}

\label{ch:robo44}
\label{ch:Datatypes_L2crange}
\index{unsorted!L2crange}\index{Structures!L2crange}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L2crange - A sub-structure of the L2ctype structure, setting valid ranges.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L2crange
    REAL(wp), DIMENSION(2) :: lat_2d            = (/  -90.0_wp,     90.0_wp /)
    REAL(wp), DIMENSION(2) :: lon_2d            = (/ -180.0_wp,    180.0_wp /)
    REAL(wp), DIMENSION(2) :: dtheta            = (/    0.0_wp,  3.14159_wp /)
    REAL(wp), DIMENSION(2) :: geop_sfc          = (/ -1.0e3_wp,    1.0e4_wp /)
    REAL(wp), DIMENSION(2) :: press_sfc         = (/  250.0_wp,   1100.0_wp /)
    REAL(wp), DIMENSION(2) :: press_sfc_sigma   = (/    0.0_wp,      5.0_wp /)
    REAL(wp), DIMENSION(2) :: press_sfc_qual    = (/    0.0_wp,    100.0_wp /)

    REAL(wp), DIMENSION(2) :: tph_bangle        = (/  6.2e6_wp,  6.6e6_wp /)
    REAL(wp), DIMENSION(2) :: tpa_bangle        = (/ -0.001_wp,     0.1_wp/)
    INTEGER,  DIMENSION(2) :: tph_bangle_flag   = (/         0,       255 /)

    REAL(wp), DIMENSION(2) :: tph_refrac        = (/ -1.0e3_wp,  1.0e5_wp /)
    REAL(wp), DIMENSION(2) :: tpn_refrac        = (/    0.0_wp,   500.0_wp/)
    INTEGER,  DIMENSION(2) :: tph_refrac_flag   = (/         0,       255 /)

    REAL(wp), DIMENSION(2) :: tph_tdry_lrt      = (/ -1.0e3_wp,  1.0e5_wp /)
    REAL(wp), DIMENSION(2) :: tpt_tdry_lrt      = (/  150.0_wp,  350.0_wp /)
    INTEGER,  DIMENSION(2) :: tph_tdry_lrt_flag = (/         0,       255 /)

    REAL(wp), DIMENSION(2) :: tph_tdry_cpt      = (/ -1.0e3_wp,  1.0e5_wp /)
    REAL(wp), DIMENSION(2) :: tpt_tdry_cpt      = (/  150.0_wp,  350.0_wp /)
    INTEGER,  DIMENSION(2) :: tph_tdry_cpt_flag = (/         0,       255 /)

    REAL(wp), DIMENSION(2) :: prh_tdry_cpt      = (/ -1.0e3_wp,  1.0e5_wp /)
    REAL(wp), DIMENSION(2) :: prt_tdry_cpt      = (/  150.0_wp,  350.0_wp /)
    INTEGER,  DIMENSION(2) :: prh_tdry_cpt_flag = (/         0,       255 /)

    REAL(wp), DIMENSION(2) :: tph_temp_lrt      = (/ -1.0e3_wp,  1.0e5_wp /)
    REAL(wp), DIMENSION(2) :: tpt_temp_lrt      = (/  150.0_wp,  350.0_wp /)
    INTEGER,  DIMENSION(2) :: tph_temp_lrt_flag = (/         0,       255 /)

    REAL(wp), DIMENSION(2) :: tph_temp_cpt      = (/ -1.0e3_wp,  1.0e5_wp /)
    REAL(wp), DIMENSION(2) :: tpt_temp_cpt      = (/  150.0_wp,  350.0_wp /)
    INTEGER,  DIMENSION(2) :: tph_temp_cpt_flag = (/         0,       255 /)

    REAL(wp), DIMENSION(2) :: prh_temp_cpt      = (/ -1.0e3_wp,  1.0e5_wp /)
    REAL(wp), DIMENSION(2) :: prt_temp_cpt      = (/  150.0_wp,  350.0_wp /)
    INTEGER,  DIMENSION(2) :: prh_temp_cpt_flag = (/         0,       255 /)
  END TYPE L2crange
\end{Verbatim}
\section{Datatypes/L2ctype}
\textsl{[ Structures ]}

\label{ch:robo45}
\label{ch:Datatypes_L2ctype}
\index{unsorted!L2ctype}\index{Structures!L2ctype}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L2ctype - A sub-structure of the ROprof structure, containing meteorological
              surface pressure.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L2ctype
    INTEGER        :: Npoints           = 0         ! No. of samples in profile (0 or 1)
    LOGICAL        :: Missing           = .TRUE.    ! No valid data if .T.
    REAL(wp)       :: geop_sfc          = ropp_MDFV ! Geopotential height of surface (m)
    REAL(wp)       :: press_sfc         = ropp_MDFV ! Surface pressure (hPa)
    REAL(wp)       :: press_sfc_sigma   = ropp_MDFV ! Est. error in surface pressure (hPa)
    REAL(wp)       :: press_sfc_qual    = ropp_MDFV ! Quality value for L2b+c (%)

    REAL(wp)       :: tph_bangle        = ropp_MDFV ! Bangle-derived TPH (m)
    REAL(wp)       :: tpa_bangle        = ropp_MDFV ! Bangle-derived TPA (rad)
    INTEGER        :: tph_bangle_flag   = ropp_MIFV ! Bangle-derived TPH QC flag

    REAL(wp)       :: tph_refrac        = ropp_MDFV ! Refrac-derived TPH (m)
    REAL(wp)       :: tpn_refrac        = ropp_MDFV ! Refrac-derived TPN (N_unit)
    INTEGER        :: tph_refrac_flag   = ropp_MIFV ! Refrac-derived TPH QC flag

    REAL(wp)       :: tph_tdry_lrt      = ropp_MDFV ! Tdry-derived TPH (lapse rate) (m)
    REAL(wp)       :: tpt_tdry_lrt      = ropp_MDFV ! Tdry-derived TPT (lapse rate) (K)
    INTEGER        :: tph_tdry_lrt_flag = ropp_MIFV ! Tdry-derived TPH (lapse rate) QC flag

    REAL(wp)       :: tph_tdry_cpt      = ropp_MDFV ! Tdry-derived TPH (cold point) (m)
    REAL(wp)       :: tpt_tdry_cpt      = ropp_MDFV ! Tdry-derived TPT (cold point) (K)
    INTEGER        :: tph_tdry_cpt_flag = ropp_MIFV ! Tdry-derived TPH (cold point) QC flag

    REAL(wp)       :: prh_tdry_cpt      = ropp_MDFV ! Tdry-derived PRH (cold point) (m)
    REAL(wp)       :: prt_tdry_cpt      = ropp_MDFV ! Tdry-derived PRT (cold point) (K)
    INTEGER        :: prh_tdry_cpt_flag = ropp_MIFV ! Tdry-derived TPH (cold point) QC flag

    REAL(wp)       :: tph_temp_lrt      = ropp_MDFV ! Temp-derived TPH (lapse rate) (m)
    REAL(wp)       :: tpt_temp_lrt      = ropp_MDFV ! Temp-derived TPT (lapse rate) (K)
    INTEGER        :: tph_temp_lrt_flag = ropp_MIFV ! Temp-derived TPH (lapse rate) QC flag

    REAL(wp)       :: tph_temp_cpt      = ropp_MDFV ! Temp-derived TPH (cold point) (m)
    REAL(wp)       :: tpt_temp_cpt      = ropp_MDFV ! Temp-derived TPT (cold point) (K)
    INTEGER        :: tph_temp_cpt_flag = ropp_MIFV ! Temp-derived TPH (cold point) QC flag

    REAL(wp)       :: prh_temp_cpt      = ropp_MDFV ! Temp-derived PRH (cold point) (m)
    REAL(wp)       :: prt_temp_cpt      = ropp_MDFV ! Temp-derived PRT (cold point) (K)
    INTEGER        :: prh_temp_cpt_flag = ropp_MIFV ! Temp-derived PRH (cold point) error flag

    TYPE(L2cunits) :: units
    TYPE(L2crange) :: range
  END TYPE L2ctype
\end{Verbatim}
\section{Datatypes/L2ctype\_2d}
\textsl{[ Structures ]}

\label{ch:robo46}
\label{ch:Datatypes_L2ctype_2d}
\index{unsorted!L2ctype\_2d}\index{Structures!L2ctype\_2d}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L2ctype_2d - A sub-structure of the ROprof structure, containing meteorological
                 surface pressure.
                 Two-dimensional meteorological data version.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L2ctype_2d
    INTEGER                         :: Npoints = 0        ! No. of samples in profile (0 or 1)
    LOGICAL                         :: Missing = .TRUE.   ! No valid data if .T.
    INTEGER                         :: Nhoriz  = 0        ! No. of horizontal locations
    REAL(wp)                        :: dtheta             ! Angle between profiles
    REAL(wp), DIMENSION(:), POINTER :: lat_2d => null()   ! Latitude position
    REAL(wp), DIMENSION(:), POINTER :: lon_2d => null()   ! Longitude position
    REAL(wp), DIMENSION(:), POINTER :: geop_sfc => null() ! Geopotential height of surface (m)
    REAL(wp), DIMENSION(:), POINTER :: press_sfc => null() ! Surface pressure (hPa)
    REAL(wp), DIMENSION(:), POINTER :: press_sfc_sigma => null() ! Est. error in sfc pressure (hPa)
    REAL(wp), DIMENSION(:), POINTER :: press_sfc_qual => null() ! Quality value for L2b+c (%)
    TYPE(L2cunits) :: units
    TYPE(L2crange) :: range
 END TYPE L2ctype_2d
\end{Verbatim}
\section{Datatypes/L2cunits}
\textsl{[ Structures ]}

\label{ch:robo47}
\label{ch:Datatypes_L2cunits}
\index{unsorted!L2cunits}\index{Structures!L2cunits}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L2cunits - A sub-structure of the L2ctype structure, defining units.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L2cunits
    CHARACTER(len = 64) :: lat_2d            = "degrees_north"
    CHARACTER(len = 64) :: lon_2d            = "degrees_east"
    CHARACTER(len = 64) :: dtheta            = "radians"
    CHARACTER(len = 64) :: geop_sfc          = "geopotential metres"
    CHARACTER(len = 64) :: press_sfc         = "hPa"
    CHARACTER(len = 64) :: press_sfc_sigma   = "hPa"
    CHARACTER(len = 64) :: press_sfc_qual    = "percent"

    CHARACTER(len = 64) :: tph_bangle        = "metres"
    CHARACTER(len = 64) :: tpa_bangle        = "radians"
    CHARACTER(len = 64) :: tph_bangle_flag   = ""

    CHARACTER(len = 64) :: tph_refrac        = "metres"
    CHARACTER(len = 64) :: tpn_refrac        = "N-units"
    CHARACTER(len = 64) :: tph_refrac_flag   = ""

    CHARACTER(len = 64) :: tph_tdry_lrt      = "metres"
    CHARACTER(len = 64) :: tpt_tdry_lrt      = "kelvin"
    CHARACTER(len = 64) :: tph_tdry_lrt_flag = ""

    CHARACTER(len = 64) :: tph_tdry_cpt      = "metres"
    CHARACTER(len = 64) :: tpt_tdry_cpt      = "kelvin"
    CHARACTER(len = 64) :: tph_tdry_cpt_flag = ""

    CHARACTER(len = 64) :: prh_tdry_cpt      = "metres"
    CHARACTER(len = 64) :: prt_tdry_cpt      = "kelvin"
    CHARACTER(len = 64) :: prh_tdry_cpt_flag = ""

    CHARACTER(len = 64) :: tph_temp_lrt      = "geopotential metres"
    CHARACTER(len = 64) :: tpt_temp_lrt      = "kelvin"
    CHARACTER(len = 64) :: tph_temp_lrt_flag = ""

    CHARACTER(len = 64) :: tph_temp_cpt      = "geopotential metres"
    CHARACTER(len = 64) :: tpt_temp_cpt      = "kelvin"
    CHARACTER(len = 64) :: tph_temp_cpt_flag = ""

    CHARACTER(len = 64) :: prh_temp_cpt      = "metres"
    CHARACTER(len = 64) :: prt_temp_cpt      = "kelvin"
    CHARACTER(len = 64) :: prh_temp_cpt_flag = ""
  END TYPE L2cunits
\end{Verbatim}
\section{Datatypes/L2drange}
\textsl{[ Structures ]}

\label{ch:robo48}
\label{ch:Datatypes_L2drange}
\index{unsorted!L2drange}\index{Structures!L2drange}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L2drange - A sub-structure of the L2dtype structure, setting valid ranges.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L2drange
    REAL(wp), DIMENSION(2) :: level_coeff_a = (/ 0.0_wp, 2000.0_wp/)
    REAL(wp), DIMENSION(2) :: level_coeff_b = (/ 0.0_wp,    2.0_wp/)
  END TYPE L2drange
\end{Verbatim}
\section{Datatypes/L2dtype}
\textsl{[ Structures ]}

\label{ch:robo49}
\label{ch:Datatypes_L2dtype}
\index{unsorted!L2dtype}\index{Structures!L2dtype}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L2dtype - A sub-structure of the ROprof structure, containing the defining
              coefficients for vertical hybrid or eta-type level structures.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L2dtype
    INTEGER                         :: Npoints       = 0
    LOGICAL                         :: Missing       = .TRUE.  ! No valid data if .T.
    CHARACTER(len = 64)             :: level_type    = "UNKNOWN"
    REAL(wp), DIMENSION(:), POINTER :: level_coeff_a => null() ! Model level coefficients
    REAL(wp), DIMENSION(:), POINTER :: level_coeff_b => null()
    TYPE(L2dunits)                  :: units
    TYPE(L2drange)                  :: range
  END TYPE L2dtype
\end{Verbatim}
\section{Datatypes/L2dunits}
\textsl{[ Structures ]}

\label{ch:robo50}
\label{ch:Datatypes_L2dunits}
\index{unsorted!L2dunits}\index{Structures!L2dunits}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    L2dunits - A sub-structure of the L2dtype structure, defining units.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE L2dunits
    CHARACTER(len = 40) :: level_coeff_a = 'hPa'
    CHARACTER(len = 40) :: level_coeff_b = ''
  END TYPE L2dunits
\end{Verbatim}
\section{Datatypes/ROcorcov}
\textsl{[ Structures ]}

\label{ch:robo51}
\label{ch:Datatypes_ROcorcov}
\index{unsorted!ROcorcov}\index{Structures!ROcorcov}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ROcorcov - Error correlation or covariance data type.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ropp_io_types
      ...
    type(ROcorcov) :: covar
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The ROcorcov structure contains an error correlation or covariance matrix
    (the latter will be splitted into an error correlation matrix and an array
    of diagonal standard deviations). The error correlation matrix is stored in
    Lapack's packed format for positive definite matrices, i.e. as a 1d array.

    As an additional element, the structure may also contain a latitude range
    pair which is intended to specify within which latitude band the error
    covariance is applicable.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE ROcorcov
    CHARACTER(len = 13) :: FmtVersion        = "UNKNOWN" ! File format version ID
    CHARACTER(len = 40) :: processing_centre = "UNKNOWN" ! Processing centre

    REAL(wp)                        :: lat_min = -90.0_wp
    REAL(wp)                        :: lat_max =  90.0_wp
    REAL(wp), DIMENSION(:), POINTER :: sigma   => null()
    REAL(wp), DIMENSION(:), POINTER :: corr    => null()
  END TYPE ROcorcov
\end{Verbatim}
\section{Datatypes/ROprof}
\textsl{[ Structures ]}

\label{ch:robo52}
\label{ch:Datatypes_ROprof}
\index{unsorted!ROprof}\index{Structures!ROprof}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ROprof - Radio Occultation data (profile) data type.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ropp_io_types
      ...
    type(ROprof) :: ro_data
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The ROprof structure is composed out of several other structures; see the user guide
    for a breakdown of the actual element names.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    DT7type
    GEOtype
    BGtype
    L1atype
    L1btype
    L2atype
    L2btype
    L2ctype
    L2dtype
    ROunits
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE ROprof
    CHARACTER(len = 21) :: FmtVersion        = "UNKNOWN" ! File format version ID
    CHARACTER(len = 40) :: occ_id            = "UNKNOWN" ! Occultation ID
    CHARACTER(len = 4)  :: leo_id            = "UNKN"    ! LEO identifier
    CHARACTER(len = 4)  :: gns_id            = "U999"    ! GNSS identifier
    CHARACTER(len = 4)  :: stn_id            = "UNKN"    ! GSN station identifier
    CHARACTER(len = 40) :: processing_centre = "UNKNOWN" ! Processing centre
    CHARACTER(len = 40) :: pod_method        = "UNKNOWN" ! POD processing method
    CHARACTER(len = 40) :: phase_method      = "UNKNOWN" ! Excess phase processing method
    CHARACTER(len = 40) :: bangle_method     = "UNKNOWN" ! Bending angle processing method
    CHARACTER(len = 40) :: refrac_method     = "UNKNOWN" ! Refractivity processing method
    CHARACTER(len = 40) :: meteo_method      = "UNKNOWN" ! Meteorological processing method
    CHARACTER(len = 80) :: thin_method       = "UNKNOWN" ! Profile thinning method
    CHARACTER(len = 40) :: software_version  = "UNKNOWN" ! Software version ID
    TYPE(DT7type)       :: DTocc                         ! Date/time of occultation
    TYPE(DT7type)       :: DTpro                         ! Date/time of processing
    INTEGER             :: PCD          = 65535          ! Product quality flags
    REAL(wp)            :: overall_qual = ropp_MDFV      ! Overall quality value
    TYPE(GEOtype)       :: georef                        ! Georeferencing of the profile
    TYPE(BGtype)        :: bg                            ! Background meta-data
    TYPE(L1atype)       :: Lev1a                         ! Level 1a data
    TYPE(L1btype)       :: Lev1b                         ! Level 1b data
    TYPE(L2atype)       :: Lev2a                         ! Level 2a data
    TYPE(L2btype)       :: Lev2b                         ! Level 2b data
    TYPE(L2ctype)       :: Lev2c                         ! Level 2c data
    TYPE(L2dtype)       :: Lev2d                         ! Level 2d data
    TYPE(ROunits)       :: units                         ! Parameter unit names
    TYPE(ROrange)       :: range                         ! Parameter ranges
    TYPE(Vlisttype)     :: vlist                         ! Additional variables
  END TYPE ROprof
\end{Verbatim}
\section{Datatypes/ROprof2d}
\textsl{[ Structures ]}

\label{ch:robo53}
\label{ch:Datatypes_ROprof2d}
\index{unsorted!ROprof2d}\index{Structures!ROprof2d}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ROprof2d - Radio Occultation data (profile) data type (two-dimensional meteorological data).
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ropp_io_types
      ...
    type(ROprof2d) :: ro_data
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The ROprof structure is composed out of several other structures; see the user guide
    for a breakdown of the actual element names.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    DT7type
    GEOtype
    BGtype
    L1atype
    L1btype
    L2atype
    L2btype_2d
    L2ctype_2d
    L2dtype
    ROunits
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE ROprof2d
    CHARACTER(len = 21) :: FmtVersion        = "UNKNOWN" ! File format version ID
    CHARACTER(len = 40) :: occ_id            = "UNKNOWN" ! Occultation ID
    CHARACTER(len = 4)  :: leo_id            = "UNKN"    ! LEO identifier
    CHARACTER(len = 4)  :: gns_id            = "U999"    ! GNSS identifier
    CHARACTER(len = 4)  :: stn_id            = "UNKN"    ! GSN station identifier
    CHARACTER(len = 40) :: processing_centre = "UNKNOWN" ! Processing centre
    CHARACTER(len = 40) :: pod_method        = "UNKNOWN" ! POD processing method
    CHARACTER(len = 40) :: phase_method      = "UNKNOWN" ! Excess phase processing method
    CHARACTER(len = 40) :: bangle_method     = "UNKNOWN" ! Bending angle processing method
    CHARACTER(len = 40) :: refrac_method     = "UNKNOWN" ! Refractivity processing method
    CHARACTER(len = 40) :: meteo_method      = "UNKNOWN" ! Meteorological processing method
    CHARACTER(len = 80) :: thin_method       = "UNKNOWN" ! Profile thinning method
    CHARACTER(len = 40) :: software_version  = "UNKNOWN" ! Software version ID
    TYPE(DT7type)       :: DTocc                         ! Date/time of occultation
    TYPE(DT7type)       :: DTpro                         ! Date/time of processing
    INTEGER             :: PCD          = 65535          ! Product quality flags
    REAL(wp)            :: overall_qual = ropp_MDFV      ! Overall quality value
    TYPE(GEOtype)       :: georef                        ! Georeferencing of the profile
    TYPE(BGtype)        :: bg                            ! Background meta-data
    TYPE(L1atype)       :: Lev1a                         ! Level 1a data
    TYPE(L1btype)       :: Lev1b                         ! Level 1b data
    TYPE(L2atype)       :: Lev2a                         ! Level 2a data
    TYPE(L2btype_2d)    :: Lev2b                         ! Level 2b data (two-dimensional)
    TYPE(L2ctype_2d)    :: Lev2c                         ! Level 2c data (two-dimensional)
    TYPE(L2dtype)       :: Lev2d                         ! Level 2d data
    TYPE(ROunits)       :: units                         ! Parameter unit names
    TYPE(ROrange)       :: range                         ! Parameter ranges
    TYPE(Vlisttype)     :: vlist                         ! Additional variables
  END TYPE ROprof2d
\end{Verbatim}
\section{Datatypes/ROrange}
\textsl{[ Structures ]}

\label{ch:robo54}
\label{ch:Datatypes_ROrange}
\index{unsorted!ROrange}\index{Structures!ROrange}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ROrange - A sub-structure of the ROprof structure, defining (top level) ranges.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE ROrange
    INTEGER,  DIMENSION(2) :: pcd          = (/ 0,      32767      /)
    REAL(wp), DIMENSION(2) :: overall_qual = (/ 0.0_wp,   100.0_wp /)
  END TYPE ROrange
\end{Verbatim}
\section{Datatypes/ROunits}
\textsl{[ Structures ]}

\label{ch:robo55}
\label{ch:Datatypes_ROunits}
\index{unsorted!ROunits}\index{Structures!ROunits}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ROunits - A sub-structure of the ROprof structure, defining (top-level) units.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  TYPE ROunits
    CHARACTER(len = 64) :: pcd          = "bits"
    CHARACTER(len = 64) :: overall_qual = "percent"
  END TYPE ROunits
\end{Verbatim}
\section{Dimensions/ncdf\_defdim}
\textsl{[ Subroutines ]}

\label{ch:robo56}
\label{ch:Dimensions_ncdf_defdim}
\index{unsorted!ncdf\_defdim}\index{Subroutines!ncdf\_defdim}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_defdim - Define a new dimension in the current netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    dimid = ncdf_defdim(name, size [, ncid])
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine creates a new dimension in the current netCDF data
    file. Error handling is done inside the routine.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    character(len = *) :: name        Name of the new dimension.
    integer            :: size        Size (length) of the new dimension.
                                      The netCDF parameter NF90_UNLIMITED
                                      may also be passed to create an
                                      unlimited netCDF variable.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    integer            :: dimid       netCDF id of the new dimension.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The returned dimid is a scalar; for use in the ncdf_defvar() function,
    arrays of dimid's are required. An unlimited dimension can be created
    by passing the appropriate len argument to this subroutine, i.e. by

       call ncdf_defdim('...', nf90_unlimited)
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_defvar
\end{Verbatim}
\section{ExtendingDatatypes/ropp\_io\_addvar}
\textsl{[ Subroutines ]}

\label{ch:robo57}
\label{ch:ExtendingDatatypes_ropp_io_addvar}
\index{unsorted!ropp\_io\_addvar}\index{Subroutines!ropp\_io\_addvar}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_addvar - Add an additional variable to an RO profile structure.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    call ropp_io_addvar(ro_data, name, long_name, units, range, data)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine extends a given RO profile structure with a variable as
    characterised by the arguments. Upon writing the variable to a netCDF
    file, additional (compared to the standard set of netCDF) variables will
    be created, using name, long_name, units and range as standard attributes
    in the netCDF data structure.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    type(ROprof)     :: ro_data
    char(len = *)    :: name
    char(len = *)    :: long_name
    char(len = *)    :: units
    real(wp), dim(2) :: range
    real(wp), dim(n) :: data
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    None; however, an additional variable with the attributes and data as
    specified via the subroutine's arguments is attached to ro_data.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    All arguments are mandatory.
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    Adding the value of a cost function to a retrieved profile:

       call ropp_io_addvar(ro_data, &
                           name      = "J", &
                           long_name = "Cost function value at convergence", &
                           units     = "", &
                           range     = (/ 0.0_wp, 9999.0_wp/), &
                           data      = J)

    A variable holding relative humidity as additional retrieved quantity
    can be created with

       call ropp_io_addvar(ro_data, &
                           name      = "rhum", &
                           long_name = "Relative humidity", &
                           units     = "percent", &
                           range     = (/ 0.0_wp, 9999.0_wp/), &
                           data      = rhum)

    where rhum is a one-dimensional double precision array.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\section{Files/is\_netcdf}
\textsl{[ Functions ]}

\label{ch:robo58}
\label{ch:Files_is_netcdf}
\index{unsorted!is\_netcdf}\index{Functions!is\_netcdf}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    is_netcdf - Check if a file is a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    true_or_false = is_netcdf(file)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This function tries to open a file as a netCDF data file, and returns
    .true. if successful, .false. otherwise.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    file           -  file to be checked.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    true_or_false  -  logical value, .true. if file is a netCDF data file.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The netCDF data file is opened and (if successful) closed again.
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    To check if a file is a netCDF, and handle the situation accordingly:

       if (is_netcdf(file)) then
          call do_this()
       else
          call do_that()
       endif
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_create
    ncdf_open
    ncdf_close
\end{Verbatim}
\section{Files/ncdf\_close}
\textsl{[ Subroutines ]}

\label{ch:robo59}
\label{ch:Files_ncdf_close}
\index{unsorted!ncdf\_close}\index{Subroutines!ncdf\_close}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_close - Close a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_close([ncid])
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine closes a netCDF data file. If ncid is not given,
    the current netCDF is closed.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    character(len = *) :: ncfile    Name of netCDF data file.
    integer            :: ncid      netCDF id.

    Note that all arguments are optional.
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    The usual steps for reading data from a netCDF file are:

       call ncdf_open(file)
          ...
    !  Read data
          ...
       call ncdf_close()
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    is_netcdf
    ncdf_open
    ncdf_create
\end{Verbatim}
\section{Files/ncdf\_create}
\textsl{[ Subroutines ]}

\label{ch:robo60}
\label{ch:Files_ncdf_create}
\index{unsorted!ncdf\_create}\index{Subroutines!ncdf\_create}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_create - Create a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_create(file [, mode] [, ncid])
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine creates a new netCDF data file.

 INPUT
    file     Name of the netCDF data file to be created.
    cmode    Mode for create. Default is NF90_CLOBBER, i.e. an existing
                file with the same name is overwritten without warning.
                An alternative is to use NF90_NOCLOBBER, which prohibits
                the accidental overwriting of an already existing file.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    ncid     NetCDF id of the opened netCDF data file.
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    To create a new netCDF file:

       call ncdf_create(file)

    Create the same file, but stop with an error message if a file of the
    same name already exist:

       call ncdf_create(file, mode = NF90_NOCLOBBER)

    Two netCDF files are created by the following commands:

       call ncdf_create(file_a, ncid = ncid_a)
       call ncdf_create(file_b, ncid = ncid_b)

    Note that the current netCDF data file known to all ncdf routines is
    the one opened last; if the first file is to be accessed, the netCDF id
    needs to be passed on to the corresponding routines via the optional
    ncid keyword. E.g.

       call ncdf_save('var_b', var)                ! --> file_b
       call ncdf_save('var_a', var, nid = ncid_a)  ! --> file_a
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    is_netcdf
    ncdf_open
    ncdl_close
\end{Verbatim}
\section{Files/ncdf\_isatt}
\textsl{[ Functions ]}

\label{ch:robo61}
\label{ch:Files_ncdf_isatt}
\index{unsorted!ncdf\_isatt}\index{Functions!ncdf\_isatt}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_isatt - Check if attribute is present in a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    true_or_false = ncdf_isatt(attname, [varid, file, xtype, len, attnum])
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This function inquires if a certain attribute (global if varid is not
    present) exists in the netCDF file. Returns .true. if successful,
    .false. otherwise.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    attname        - attribute name (global or local)
    varname        - variable name (optional)
    ncfile         - name of file to be searched (optional)
    ncid           - ID of file to be searched (optional)
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    true_or_false  - logical value, .true. if attribute exists in netCDF data file.
    xtype          - optional, type of attribute following netCDF library settings:
                         NF90_BYTE, NF90_CHAR, NF90_SHORT, NF90_INT,
                         NF90_FLOAT, and NF90_DOUBLE
    len            - optional, length of attribute
    attnum         - optional, attribute nubmer
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    By default, the current netCDF file is searched, else the optionally
    file by name or by ID (name takes precedence if both are given)
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    To check if an attribute exists in the currently open file,
    and handle the situation accordingly:

       if (ncdf_isatt('history')) then
          call do_this()
       else
          call do_that()
       endif
    Check also for optional arguments:
     - global attribute:
       ncdf_isatt('software_version', ncfile=ncfile, xtype=xtype, len=len, attnum=attnum)
     - local attribute of variable
       ncdf_isatt('units', 'temperature', 'myfile.nc', xtype, len, attnum)
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_create
    ncdf_open
    ncdf_close
    is_netcdf
\end{Verbatim}
\section{Files/ncdf\_open}
\textsl{[ Subroutines ]}

\label{ch:robo62}
\label{ch:Files_ncdf_open}
\index{unsorted!ncdf\_open}\index{Subroutines!ncdf\_open}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_open - Open a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_open(file [, ncid][, mode = ...][, append = [.true.|.false.]])
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine opens an already existing netCDF data file. If the file
    does not exist, an error will occur.

 INPUT
    character(len = *) :: file      file to be opened.
    integer            :: mode      mode in which the file is to be opened
                                       (as defined in thenetCDF documentation)
    logical            :: append    if .true., this is equivalent to
                                       mode = nf90_write
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    ncid   - netCDF id of the opened netCDF data file.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The default is to open the netCDF in (shared) read-only mode. Setting the
    logical argument append to .true. overwrites all mode = settings.
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    To read the scalar variables var_a and var_b can be read from a netCDF
    data file named 'test.nc':

       real :: a, b
         ...
       call ncdf_open('test.nc')
       call ncdf_getvar('var_a', a)
       call ncdf_getvar('var_b', b)
       call ncdf_close()
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    is_netcdf
    ncdf_create
    ncdf_close
\end{Verbatim}
\section{Files/ncdf\_sync}
\textsl{[ Subroutines ]}

\label{ch:robo63}
\label{ch:Files_ncdf_sync}
\index{unsorted!ncdf\_sync}\index{Subroutines!ncdf\_sync}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_sync - Synchronise the current netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_sync(ncfile = ..., ncid = ...)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine synchronises the current netCDF data file to disc.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    character(len = *) :: ncfile    Name of netCDF data file.
    integer            :: ncid      netCDF id.

    Note that all arguments are optional.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    None.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    NetCDF data files open for writing allow to continuously add data to
    the file, but need to be synchronised to disc before newly added data
    can be accessed. Synching the file's contents always happens when
    closing the netCDF, but some information might be required earlier and
    without having to close and reopen the file. An example is obtaining
    the number of records written so far.

    Calling ncdf_sync() only makes sense if data has been written to a
    netCDF file before. It probably involves some system overhead.
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    Assume that you have written several records to a data file and have
    to infer about characteristics of the written data - like the number
    of records already written. Try

       use ncdf
         ...
       integer              :: n
         ...
       call ncdf_create('test.nc')
         ...
       <define variables>
         ...
       <write part of the data>
         ...
       call ncdf_sync()
       n = ncdf_getnrec()
         ...
       call ncdf_close()
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_create
    ncdf_open
    ncdf_close
    ncdf_putvar
\end{Verbatim}
\section{Information/ropp\_io\_nrec}
\textsl{[ Functions ]}

\label{ch:robo64}
\label{ch:Information_ropp_io_nrec}
\index{unsorted!ropp\_io\_nrec}\index{Functions!ropp\_io\_nrec}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_nrec - Number of records (e.g., vertical profiles) in an ROPP file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    n = ropp_io_nrec(file)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This function returns the number of records (e.g., vertical profiles)
    in a netCDF based ROPP data file. 
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    char :: file   Name of data file to query.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    int  :: n      Number of records; -1 if the data file is not a netCDF.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    No attempt is made to check if the queried data file is indeed an ROPP
    data file, or simply an ordinary netCDF data file.

    If the quieried netCDF file is an ordinary netCDF file and has no
    unlimited dimension, an error message might occur.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\section{Initialisation/PCD\_parametres}
\textsl{[ Parameters ]}

\label{ch:robo65}
\label{ch:Initialisation_PCD_parametres}
\index{unsorted!PCD\_parametres}\index{Parameters!PCD\_parametres}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    PCD parametres - Parametres for setting and testing the Product Confidence
                     Data (PCD) element of the ROprof structure.
\end{Verbatim}
\textbf{SOURCE:}\hspace{0.08in}\begin{Verbatim}
  INTEGER, PARAMETER :: PCD_summary      =  0  ! Nominal / non-nominal quality
  INTEGER, PARAMETER :: PCD_offline      =  1  ! NRT / offline product
  INTEGER, PARAMETER :: PCD_rising       =  2  ! Setting / rising occultation
  INTEGER, PARAMETER :: PCD_phase        =  3  ! Phase processing      nominal / non-nominal
  INTEGER, PARAMETER :: PCD_bangle       =  4  ! Bending angle proc.   nominal / non-nominal
  INTEGER, PARAMETER :: PCD_refrac       =  5  ! Refractivity proc.    nominal / non-nominal
  INTEGER, PARAMETER :: PCD_met          =  6  ! Meteorological. proc. nominal / non-nominal
  INTEGER, PARAMETER :: PCD_open_loop    =  7  ! Open Loop data used   no / yes
  INTEGER, PARAMETER :: PCD_reflections  =  8  ! Surface reflections detected no / yes
  INTEGER, PARAMETER :: PCD_l2_signal    =  9  ! L2 GPS signal used    L2P / L2C
  INTEGER, PARAMETER :: PCD_reserved_11  = 10  ! Reserved
  INTEGER, PARAMETER :: PCD_reserved_12  = 11  ! Reserved
  INTEGER, PARAMETER :: PCD_reserved_13  = 12  ! Reserved
  INTEGER, PARAMETER :: PCD_bg           = 13  ! Background profile nominal / non-nominal
  INTEGER, PARAMETER :: PCD_occultation  = 14  ! Occultation / background profile
  INTEGER, PARAMETER :: PCD_missing      = 15  ! PCD missing
\end{Verbatim}
\section{Initialisation/ropp\_io\_ascend}
\textsl{[ Functions ]}

\label{ch:robo66}
\label{ch:Initialisation_ropp_io_ascend}
\index{unsorted!ropp\_io\_ascend}\index{Functions!ropp\_io\_ascend}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_ascend - ensure all profiles are in ascending altitude order
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   CALL ropp_io_ascend ( ROdata )
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   ROdata  struc  RO data structure (original)

 OUTPUTS
   ROdata  struc  RO data structure (inverted as necessary)
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
    reverse
\end{Verbatim}
\textbf{USES:}\hspace{0.08in}\begin{Verbatim}
   typsesizes
   ropp_io
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   This subroutine tests the height-based parameter arrays for the
   numerical difference between the first and last valid altitude values.
   If the last is greater than the first, then the profile is assumed
   to be in ascending order and we just return to the caller. Otherwise,
   all parameters in the profile are inverted. The procedure is applied
   to Level 1b, Level 2a, and Level 2b parts of the profiles 
   separately. As Level 1a data is time-based and Level 2c is surface data
   these parts are not processed.
   Note: There is no checking that altitudes are monotonically increasing.
\end{Verbatim}
\section{Initialisation/ropp\_io\_assign}
\textsl{[ Subroutines ]}

\label{ch:robo67}
\label{ch:Initialisation_ropp_io_assign}
\index{unsorted!ropp\_io\_assign}\index{Subroutines!ropp\_io\_assign}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_assign - Initialise an RO derived type with another RO derived type
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ropp_io
    type(ROprof) :: ro_data
      ...
    call ropp_io_assign(ro_data_old, ro_data_new) 
    call ropp_io_assign(ro_data%Lev1a_old, ro_data%Lev1a_old)
    call ropp_io_assign(ro_data%Lev1b_old, ro_data%Lev1b_old)
    call ropp_io_assign(ro_data%Lev2a_old, ro_data%Lev2a_old)
    call ropp_io_assign(ro_data%Lev2b_old, ro_data%Lev2b_old)
    call ropp_io_assign(ro_data%Lev2c_old, ro_data%Lev2c_old)
    call ropp_io_assign(ro_data%Lev2d_old, ro_data%Lev2d_old)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   This subroutine initialises a RO data structure or parts thereof with the 
   elements of an exisitng RO data structure.
   These subroutines can be used to overloading the assign operator (=)
   for RO data structures

 INPUT
    ro_data_old   dtyp  RO data (derived type)
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    ro_data_new   dtyp  RO data (derived type)
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_types
    ropp_io_init
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
    Format Definition for Radio Occultation Files -
    CLIMAP Format Version 2.2a, Issue 1.6, 8 January 2004
\end{Verbatim}
\section{Initialisation/ropp\_io\_free}
\textsl{[ Subroutines ]}

\label{ch:robo68}
\label{ch:Initialisation_ropp_io_free}
\index{unsorted!ropp\_io\_free}\index{Subroutines!ropp\_io\_free}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_free - Free arrays within an an RO derived type
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ropp_io
    type(ROprof) :: ro_data
      ...
    call ropp_io_free(ro_data)

      - or -

    call ropp_io_free(ro_data%Lev1a)
    call ropp_io_free(ro_data%Lev1b)
    call ropp_io_free(ro_data%Lev2a)
    call ropp_io_free(ro_data%Lev2b)
    call ropp_io_free(ro_data%Lev2c)
    call ropp_io_free(ro_data%Lev2d)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   This subroutine frees memory from a previously initialised RO data structure
   or parts thereof; scalar values are set to their 'missing' data status again.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    ro_data   dtyp  RO data (derived type)
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_types
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    Calling the deallocation / freeing routines for individual sublevels of
    the input data structure is NOT equivalent to reeing the same data
    structure in one go, as the header data is only reset to its default
    (missing) values in the second case.

    Meta data information like units and ranges are NOT changed back to their
    default values, but left with the definition as set by the user.

    The current interface only allows the deallocation of scalar structures.
    To free an array of structures (e.g., as obtained from reading a multifile),
    a loop over all elements of the array of structures is required:

       do i = 1, size(ro_data)
          call ropp_io_free(ro_data(i))
       enddo
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
    Format Definition for Radio Occultation Files -
    CLIMAP Format Version 2.2a, Issue 1.6, 8 January 2004
\end{Verbatim}
\section{Initialisation/ropp\_io\_init}
\textsl{[ Subroutines ]}

\label{ch:robo69}
\label{ch:Initialisation_ropp_io_init}
\index{unsorted!ropp\_io\_init}\index{Subroutines!ropp\_io\_init}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_init - Initialise an RO derived type with dummy 'missing' data
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ropp_io
    type(ROprof) :: ro_data
      ...
    call ropp_io_init(ro_data, NLev1a, NLev1b, NLev2a, NLev2b, Nlev2c, NLev2d)
    call ropp_io_init(ro_data%Lev1a, NLev1a)
    call ropp_io_init(ro_data%Lev1b, NLev1b)
    call ropp_io_init(ro_data%Lev2a, NLev2a)
    call ropp_io_init(ro_data%Lev2b, NLev2b)
    call ropp_io_init(ro_data%Lev2c, NLev2c)
    call ropp_io_init(ro_data%Lev2d, NLev2d)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   This subroutine initialises a RO data structure or parts thereof with dummy
   or 'missing' data values for all elements, appropriate to the parameter and
   suitable for the ROPP data format.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    ro_data   dtyp  RO data (derived type)
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_types
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The subroutine call ropp_io_init() for level2c data (i.e., surface parameters)
    does not do much - it simply sets the number of elements to 1, regardless of
    the argument. The subroutine is available for the sake of user interface
    consistency only.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
    Format Definition for Radio Occultation Files -
    CLIMAP Format Version 2.2a, Issue 1.6, 8 January 2004
\end{Verbatim}
\section{Initialisation/ropp\_io\_occid}
\textsl{[ Subroutines ]}

\label{ch:robo70}
\label{ch:Initialisation_ropp_io_occid}
\index{unsorted!ropp\_io\_occid}\index{Subroutines!ropp\_io\_occid}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_occid - Generate an Occultation ID suitable for a file name.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ropp_io
    type(ROprof) :: ROdata
     ...
    call ropp_io_occid(ROdata)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine generates a unique occultation identifier of the form:

       tt_yyyymmddhhmmss_llll_gggg_cccc

    where:

       tt             is 'OC' for measured or retrieved occultation
                      or 'BG' for background data (e.g. from an NWP model)
       yyyymmddhhmmss is the date & time of the occultation
       llll           is the LEO  (Rx) 4-chr identifier
       gggg           is the GNSS (Tx) 4-chr identifier
       cccc           is the processing centre identifier (1st 4 chrs,
                      padded with underscores if neccessary)

    All these elements are as extracted from the RO derived type, and
    the occultion ID is returned in that structure. Basic Q/C is applied
    to the elements used for the occultaton ID only to ensure correct
    formatting of the ID string; the elements themselves are not changed.

 INPUT
   ROdata  dtyp  RO data structure (derived type)
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
   ROdata  dtyp  RO data structure (derived type)
\end{Verbatim}
\textbf{USES:}\hspace{0.08in}\begin{Verbatim}
  ropp_io
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   To_Upper
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
   The subroutines requires that the PCD_occultation flag (specifying whether
   the data originates from an occultation measurement and / or retrieval or
   background data is set properly.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
    ROPP User Guide. Part I. Ref: SAF/ROM/METO/UG/ROPP/002
\end{Verbatim}
\section{Initialisation/ropp\_io\_rangecheck}
\textsl{[ Subroutines ]}

\label{ch:robo71}
\label{ch:Initialisation_ropp_io_rangecheck}
\index{unsorted!ropp\_io\_rangecheck}\index{Subroutines!ropp\_io\_rangecheck}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_rangecheck - Check parameter ranges within an RO derived type
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   TYPE(ROprof) :: ROdata
   CALL ropp_io_rangecheck ( ROdata )

       - or -

   CALL ropp_io_rangecheck ( ROdata%Lev1a)
   CALL ropp_io_rangecheck ( ROdata%Lev1b)
   CALL ropp_io_rangecheck ( ROdata%Lev2a)
   CALL ropp_io_rangecheck ( ROdata%Lev2b)
   CALL ropp_io_rangecheck ( ROdata%Lev2c)
   CALL ropp_io_rangecheck ( ROdata%Lev2d)

 INPUT
   ROdata     struc  RO profile structure
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
   ROdata     struc  RO profile structure with invalid values
                     set to appropriate 'missing data' values
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_occid
   where
\end{Verbatim}
\textbf{USES:}\hspace{0.08in}\begin{Verbatim}
   typesizes
   ropp_io_types
   ropp_io
   ropp_utils
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   This subroutine check the values of all core numeric ROPP
   parameters against their range attributes and if out-of-range,
   substitutes an appropriate missing data flag value.
   Longitudes in the range 180 to 360 deg. are treated as valid
   but are converted to the range -180 to 0 deg.
   Character parameters are made upper case, with some restricted
   to alpha-numeric and underscore characters.
   Profile levels having missing coordinates (time offset for
   level 1a, Impact Parameter for L1b, geometric height for L2a or
   geopotential height for L2c & L2d) are filtered out.
   Profiles having at least one valid coordinate but no valid
   observational data (e.g. SNR/phase, BA, REF or T/q/P) are flagged
   as 'missing'.
\end{Verbatim}
\section{Initialisation/ropp\_io\_shrink}
\textsl{[ Subroutines ]}

\label{ch:robo72}
\label{ch:Initialisation_ropp_io_shrink}
\index{unsorted!ropp\_io\_shrink}\index{Subroutines!ropp\_io\_shrink}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_shrink - Copy subset of ROprof structure to itself
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ropp_io
    type(ROprof) :: ro_data
      ...
    call ropp_io_shrink(ro_data, imin, imax)

      - or -

    call ropp_io_shrink(ro_data%Lev1a, imin, imax, stride)
    call ropp_io_shrink(ro_data%Lev1b, imin, imax, stride)
    call ropp_io_shrink(ro_data%Lev2a, imin, imax, stride)
    call ropp_io_shrink(ro_data%Lev2b, imin, imax, stride)
    call ropp_io_shrink(ro_data%Lev2c, imin, imax, stride)
    call ropp_io_shrink(ro_data%Lev2d, imin, imax, stride)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine copies data to be kept from the ROprof structure to a
    local temporary storage, reallocates the array and copies data back.
    Only single chunks of data are copied (i.e. all data between imin and
    imax inclusively are kept). All elements within a data Level are copied
    between the same limits.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    ro_data   dtyp  RO data (derived type)
    imin            Initial index
    imax            Final index
    stride          Sampling interval
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    ro_data   dtyp  RO data (derived type)
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_types
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The current interface only allows the shrinking of scalar structures.
    To shrink an array of structures (e.g., as obtained from reading a multifile),
    a loop over all elements of the array of structures is required:

       do i = 1, size(ro_data)
          call ropp_io_shrink(ro_data(i), imin, imax, stride)
       enddo
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\section{Misc/ncdf\_date\_and\_time}
\textsl{[ Subroutines ]}

\label{ch:robo73}
\label{ch:Misc_ncdf_date_and_time}
\index{unsorted!ncdf\_date\_and\_time}\index{Subroutines!ncdf\_date\_and\_time}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_date_and_time - Get data and time from the operating system.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_date_and_time()
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This routine provides an alternative to Fortran 90's standard 
    date_and_time() routine.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    date
    time
    zone
    values
    year
    month
    day
    hour
    min
    sec
    msec
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    All arguments are optional. The array values is an 8-element integer
    vector, all following arguments are scalar integers. the arguments
    date, time and zone are character strings.
\end{Verbatim}
\section{Misc/ncdf\_datmode}
\textsl{[ Functions ]}

\label{ch:robo74}
\label{ch:Misc_ncdf_datmode}
\index{unsorted!ncdf\_datmode}\index{Functions!ncdf\_datmode}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_datmode - Put the current netCDF into data (i.e., out of define) mode.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_datmode()
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    Takes an open netCDF dataset out of define mode. The changes made to the
    netCDF dataset while it was in define mode are checked and committed to
    disk if no problems occurred. After a successful call, variable data can
    be read or written to the dataset.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The netCDF data file must have been opened before. If a netCDF
    data has just been opened, it already is in data mode.

    This routine does not check for errors; if switching into data
    mode is not possible, this is either because it already is in
    this mode (e.g., after being opened), in which case we don't
    care, or some other problem, in which case the next operation is
    likely to fail.
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    To read or write variables or attributes from or to a netCDF data
    file after having added new attributes and/or variables, do

       call ncdf_defmode()
          ...
       <define variables, attributes, etc.>
          ...
       call ncdf_datmode()
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_defmode
    ncdf_create
    ncdf_open
    ncdf_close
\end{Verbatim}
\section{Misc/ncdf\_defmode}
\textsl{[ Functions ]}

\label{ch:robo75}
\label{ch:Misc_ncdf_defmode}
\index{unsorted!ncdf\_defmode}\index{Functions!ncdf\_defmode}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_defmode - Put the current netCDF into define mode.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_defmode()
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    Puts the current netCDF dataset into define mode, so that
    dimensions, variables, and attributes can be added or renamed
    and attributes  can be deleted.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The netCDF data file must have been opened before. If a netCDF
    data has just been created, it already is in define mode.

    This routine does not check for errors; if switching into define
    mode is not possible, this is either because it already is in
    this mode (e.g., after being created), in which case we don't
    care, or some other problem, in which case the next operation is
    likely to fail.
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    To define (additional) variables or attributes in a netCDF data
    file, do

       call ncdf_defmode()
          ...
       <define variables, attributes, etc.>
          ...
       call ncdf_datmode()
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_datmode
    ncdf_create
    ncdf_open
    ncdf_close
\end{Verbatim}
\section{Misc/ncdf\_error\_handler}
\textsl{[ Subroutines ]}

\label{ch:robo76}
\label{ch:Misc_ncdf_error_handler}
\index{unsorted!ncdf\_error\_handler}\index{Subroutines!ncdf\_error\_handler}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_error_handler - (Internal) error handler for the ncdf library.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    status = <some netCDF function>
    if (status /= nf90_noerr) call ncdf_error_handler(status)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine issues a textual error message from a netCDF error status.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    integer     :: status
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    Assume that you want to read variables alpha_b and impact from a netCDF
    data file 'test.nc', try

       use ncdf
         ...
       integer, parameter   :: n_levels = <some_number>
         ...
       real(dp)             :: alpha(n_levels), impact(n_levels)
         ...
       call ncdf_create('test.nc')
         ...
       status = nf90_put_att(ncdf_ncid, nf90_global, "title", trim(title))
        if (status /= nf90_noerr) call ncdf_error_handler(status)
\end{Verbatim}
\section{Modules/ropp\_io}
\textsl{[ Modules ]}

\label{ch:robo77}
\label{ch:Modules_ropp_io}
\index{unsorted!ropp\_io}\index{Modules!ropp\_io}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ropp_io - The ROPP input / output library.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ropp_io
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This Fortran module provides interfaces and data types required for the
    use of the ROPP input / output library.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    For reading data from ROPP data files, the ropp_io_read routine is the
    primary interface to the library. This routine will return a Fortran
    derived type - or structure - "ROprof" which, on return, holds the
    contents of the data file. Writing data to a ROPP data file requires
    filling an instance of a ROprof data structure with the data to written.
    The arrays contained in this structure might be initialised by a call to
    ropp_io_init. The actual writing to a data file is performed using
    the subroutine ropp_io_write.

    The data format is based on the netCDF scientific data format.
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    Assume that a data file shall be read into a Fortran program; the
    required steps are

       use ropp_io
         ...
       type(ROprof)       :: ro_data
         ...
       character(len = *) :: file = 'my_data_file.nc'
         ...
       call ropp_io_read(ro_data, file)

    Similarly, writing a RO profile contains of the following steps:

       use ropp_io
         ...
       type(ROprof)       :: ro_data
         ...
       character(len = *) :: file = 'my_data_file.nc'
         ...

    !  Fill the structure
    !  ------------------

       call ropp_io_init(ro_data, NLev1a, NLev1b, NLev2a, NLev2b, NLev2c, NLev2d)
         ...

    !  Fill the structure
    !  ------------------

       ro_data%Lev1b%impact_L1 = ...
       ro_data%Lev1b%bangle_L1 = ...

    !  Write the data
    !  --------------

       call ropp_io_write(ro_data, file)
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_types
    ropp_io_read
    ropp_io_write
\end{Verbatim}
\section{Modules/ropp\_io\_types}
\textsl{[ Modules ]}

\label{ch:robo78}
\label{ch:Modules_ropp_io_types}
\index{unsorted!ropp\_io\_types}\index{Modules!ropp\_io\_types}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_types - Type declarations for the ROPP IO library.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ropp_io
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This Fortran module supports the ROPP input / output library and provides
    derived data types used by the ropp_io library. It must be loaded for all
    applications using the ropp_io library / package. Note that loading the
    ropp_io module includes the ropp_io_types module
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_types
    ropp_io_init
    ropp_io_free
    ropp_io_read
    ropp_io_write
\end{Verbatim}
\section{Programs/bgrasc2ropp}
\textsl{[ Programs ]}

\label{ch:robo79}
\label{ch:Programs_bgrasc2ropp}
\index{unsorted!bgrasc2ropp}\index{Programs!bgrasc2ropp}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   bgrasc2ropp
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Convert ASCII file containing background profile data to ROPP netCDF

   > bgrasc2ropp file_in [-o <file_out>] [-n] [-d] [-h] [-v]
\end{Verbatim}
\textbf{ARGUMENTS:}\hspace{0.08in}\begin{Verbatim}
   file_in - ascii file containing Level 2b background data
             in a fortran namelist.
             There is no default for this argument.
\end{Verbatim}
\textbf{OPTIONS:}\hspace{0.08in}\begin{Verbatim}
  -o <file_out> - is the output netCDF file name.
  -n - switches off range checking before writing ROPP file
  -d - writes additional diagnostic information to stdout
  -h - help
  -v - version information
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   Ascii file holding a fortran namelist "bgr_profile" containing those
   elements of the {bg, GEOref, Lev2b, Lev2c and Lev2d} substructures 
   of the ROprof structure needed by the ropp forward model. 
   This namelist could be generated from ECMWF grib data by the sister tool
   ropp_io/tools/grib2bgrasc.

 OUTPUTS
   ROPP netCDF file, suitable for use by ropp_fm/tools/ropp_fm_bg2ro_1d

 MODULES
   typesizes
   messages
   ropp_utils
   ropp_io_types
   ropp_io
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   usage
   ropp_io_init
   ropp_io_write
   ropp_io_free
   ropp_io_version
   message
   message_set_routine
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Conversion of level bg/GEOref/2b/2c/2d background profile data in fortran namelist 
   format to ROPP netCDF format. The input file is in the same format as that 
   produced by the sister program grib2bgrasc, which extracts a profile from a GRIB2 format model dump. 
   The data is then written out to a ROPP-standard netCDF file in PWD.

 RESTRICTIONS
   1) Assumes ECMWF-like model level structures.
   2) Users needing to read in more than 200 levels of data will have to
      increase Nlevs_max and recompile.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1. ROPP User Guide - Part I: I/O module.
      SAF/ROM/METO/UG/ROPP/002
\end{Verbatim}
\section{Programs/bufr2ropp\_ec}
\textsl{[ Programs ]}

\label{ch:robo80}
\label{ch:Programs_bufr2ropp_ec}
\index{unsorted!bufr2ropp\_ec}\index{Programs!bufr2ropp\_ec}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   bufr2ropp    (bufr2ropp_ec.f90)
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Decode RO BUFR message(s) to ROPP file(s) [ECMWF library]

   > export BUFR_TABLES=bufr_directory_path
   > bufr2ropp bufr_file [bufr_file...] [-o ropp_file] [-m] [-a]
                         [-f first] [-n number] [-d] [-h] [-v]
\end{Verbatim}
\textbf{ARGUMENTS:}\hspace{0.08in}\begin{Verbatim}
   bufr_file - one or more files containing BUFR messages
\end{Verbatim}
\textbf{OPTIONS:}\hspace{0.08in}\begin{Verbatim}
   Option switches can be in any order and are case-insensitive;
   any space(s) between a switch and its (madatory) argument is
   optional.
     -o  specify the ROPP output file name. Not recommended if more
         than one RO BUFR message could be decoded.
     -f  specify the first RO BUFR message to decode
         (ie skip first-1 messages)
     -n  specify the maximum number of RO messages to decode
     -d  to output additional diagnostics
     -h  help
     -v  version information
   Defaults:
     Input file name  : ropp.bufr
     Output file name : <occid>.nc  (netCDF)
     first            : 1
     number           : 999999 (all)
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   bufr_file is the input file containing BUFR message(s).
             The input file can contain any number of aribitrary
             BUFR messages, but any which do not contain RO data
             (or have coding errors) will be ignored. (See Ref.1)

 OUTPUTS
   ropp_file is the output file, which will be created in ROPP netCDF.
             The output file name is optional, and if not specified,
             is generated from the occulation ID.
             One output file will be written for each input RO
             BUFR message. NB: as any existing output file will be
             overwritten, using the -o option could lose data if
             there is more than one RO BUFR message in the input
             file. If this is a possibility, let the program
             generate default (and unique) file names. (See Ref.2)
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   IARGC
   GetOptions
   ReplicationCount
   ConvertBUFRtoROPP
   ropp_io_init
   ropp_io_write
   ropp_io_nrec
   ropp_io_free
   ropp_io_version
   PBOPEN
   PBCLOSE
   PBBUFR
   BUFREX
   BUSEL
   Date_and_Time_UTC
   File_Delete
   message
   message_set_routine

 MODULES
   bufr2ropp      - fixed parameter definitions & common routines
   ropp_io        - ROPP I/O file support
   ropp_io_types  - ROPP derived type definitions
   BUFRutils      - BUFR utility routines
   DateTimeProgs  - Date & Time conversion routines
   DateTimeTypes  - Date & Time conversion definitions

 DEPENDENCIES
   ECMWF BUFR package  - BUFR kernel routines
   ROPP I/O library    - ROPP file I/O support
   ROPP Utils library  - ROPP utility routines
   netCDF library      - netCDF file support
   roppbufrcodes.nl    - NAMELIST file (in BUFR_TABLES)
\end{Verbatim}
\textbf{ENVIRONMENT VARIABLES:}\hspace{0.08in}\begin{Verbatim}
   BUFR_TABLES         - path for run-time files

 ERRORS
   Program (shell) return codes:
     0 = OK
     1 = I/O error
     2 = Memory allocation failure
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   A BUFR decoder for Radio Occultation data.
   By default, outputs one ROPP file per RO BUFR message in the
   input file.
   Options are available to skip a first block of messages,
   to limit the number of decoded messages and to append decoded
   messages to a single output file.
   BUFR tables are found via the environment variable 'BUFR_TABLES'.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1) WMO FM94 (BUFR) Specification for ROM SAF Processed Radio
      Occultation Data.
      SAF/ROM/METO/FMT/BUFR/001
   2) ROPP User Guide - Part 1: UTILS and IO
      SAF/GRAS/METO/FMT/ROPP/002
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
   bufr2ropp(1), ropp2bufr(1)
\end{Verbatim}
\section{Programs/bufr2ropp\_mo}
\textsl{[ Programs ]}

\label{ch:robo81}
\label{ch:Programs_bufr2ropp_mo}
\index{unsorted!bufr2ropp\_mo}\index{Programs!bufr2ropp\_mo}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   bufr2ropp    (bufr2ropp_mo.f90)
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Decode RO BUFR message(s) to ROPP file(s) [MetDB library]

   > export BUFR_LIBRARY=bufr_directory_path
   > bufr2ropp bufr_file [bufr_file...] [-o ropp_file] [-m] [-a]
                         [-f first] [-n number] [-d] [-h] [-v]
\end{Verbatim}
\textbf{ARGUMENTS:}\hspace{0.08in}\begin{Verbatim}
   bufr_file - one or more files containing BUFR messages
\end{Verbatim}
\textbf{OPTIONS:}\hspace{0.08in}\begin{Verbatim}
   Option switches can be in any order and are case-insensitive;
   any space(s) between a switch and its (madatory) argument is
   optional.
     -o  specify the ROPP output file name. Not recommended if more
         than one RO BUFR message could be decoded.
     -f  specify the first RO BUFR message to decode
         (ie skip first-1 messages)
     -n  specify the maximum number of RO messages to decode
     -d  to output additional diagnostics
     -h  help
     -v  version information
   Defaults:
     Input file name  : ropp.bufr
     Output file name : <occid>.nc  (netCDF)
     first            : 1
     number           : 999999 (all)
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   bufr_file is the input file containing BUFR message(s).
             The input file can contain any number of aribitrary
             BUFR messages, but any which do not contain RO data
             (or have coding errors) will be ignored. (See Ref.1)

 OUTPUTS
   ropp_file is the output file, which will be created in ROPP netCDF.
             The output file name is optional, and if not specified,
             is generated from the occulation ID.
             One output file will be written for each input RO
             BUFR message. NB: as any existing output file will be
             overwritten, using the -o option could lose data if
             there is more than one RO BUFR message in the input
             file. If this is a possibility, let the program
             generate default (and unique) file names. (See Ref.2)
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   IARGC
   GetOptions
   ReplicationCount
   ConvertMOtoEC
   ConvertBUFRtoROPP
   ropp_io_init
   ropp_io_write
   ropp_io_nrec
   ropp_io_free
   ropp_io_version
   BUFRREAD
   DEBUFR
   Date_and_Time_UTC
   File_Delete
   message
   message_set_routine

 MODULES
   bufr2ropp      - fixed parameter definitions & common routines
   messages       - ROPP message library
   ropp_io        - ROPP I/O file support
   ropp_io_types  - ROPP derived type definitions
   BUFRutils      - BUFR utility routines
   DateTimeProgs  - Date & Time conversion routines

 DEPENDENCIES
   MetDB BUFR package  - BUFR kernel routines
   ROPP I/O library    - ROPP file I/O support
   ROPP Utils library  - ROPP utility routines
   netCDF library      - netCDF file support
   roppbufrcodes.nl    - NAMELIST file (in BUFR_LIBRARY)
\end{Verbatim}
\textbf{ENVIRONMENT VARIABLES:}\hspace{0.08in}\begin{Verbatim}
   BUFR_LIBRARY        - path for run-time files

 ERRORS
   Program (shell) return codes:
     0 = OK
     1 = I/O error
     2 = Memory allocation failure
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   A BUFR decoder for Radio Occultation data.
   By default, outputs one ROPP file per RO BUFR message in the
   input file.
   Options are available to skip a first block of messages,
   to limit the number of decoded messages and to append decoded
   messages to a single output file.
   BUFR tables are found via the environment variable 'BUFR_LIBRARY'.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1) WMO FM94 (BUFR) Specification for ROM SAF Processed Radio
      Occultation Data.
      SAF/ROM/METO/FMT/BUFR/001
   2) ROPP User Guide - Part 1: UTILS and IO
      SAF/GRAS/METO/FMT/ROPP/002
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
   bufr2ropp(1), ropp2bufr(1)
\end{Verbatim}
\section{Programs/eum2bufr\_ec}
\textsl{[ Programs ]}

\label{ch:robo82}
\label{ch:Programs_eum2bufr_ec}
\index{unsorted!eum2bufr\_ec}\index{Programs!eum2bufr\_ec}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ropp2bufr    (eum2bufr_mo.f90)
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Encode an EUMETSAT file to WMO FM-94 (BUFR) [ECMWF library]

   > export BUFR_TABLES=bufr_directory_path
   > eum2bufr ropp_file [ropp_file...] [-o bufr_file]
                         [-g[i]] [-s csn_file]
                         [-p thin_file] [-t time] [-r resn]
                         [-u] [-l] [-m] [-h|?] [-v] [-d]
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   eum_file is the input file(s) which must be in EUM netCDF
             4 format
 OUTPUTS
   bufr_file is the output file, which will contain one encoded
             BUFR message per input profile (See Ref.2)
             The output file name is optional, and if not specified,
             is generated from the occulation ID.
\end{Verbatim}
\textbf{OPTIONS:}\hspace{0.08in}\begin{Verbatim}
   Option switches can be in any order and are case-insensitive;
   any space(s) between a switch and its (madatory) argument is
   optional.
     -o  specifies the BUFR output file name
     -g  specifies that GTS routing headers/trailers are required
     -gi speciifes that GTS headers include a 10-byte leading size/type
         (required for some TCP/IP (FTP) implimentations for GTS)
     -s  specifies a channel sequence number file
     -p  specifies a thinning control file or max. no. of levels
     -t  specifies a time (age) rejection threshold
     -u  leave profiles unordered - disables the default re-ordering
         of output profiles to ascending.
         NB: using -u, profiles thinned using one of the interpolation methods
         will retain the order of the fixed levels in the control file; other
         methods will retain the ordering of the input profiles.
     -l  do not encode L1+L2 data (bending angle, Level 1b), if present
     -m  do not encode met.  data (geophysical, Level 2b,c), if present
     -r  resolution group of netCDF4 EUM file
     -d  to output additional diagnostics
     -h or ? to output summary help
     -v  to output program version ID
   Defaults
     Input file name         : ropp.n4
     Output file name        : <occid>.bufr
     GTS routing headers     : not generated
     Channel sequence        : initialised at 001
     Time threshold          : 00:00 (no cut-off) unless one of
                               -g options present, when 23:50
     Encode                  : all available Level 1b, 2b & 2c data
     Thinning                : sample to no more than 375 levels
     Resolution              : 'thinned'
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   IARGC
   ConvertROPPtoBUFR
   EncodeBUFR
   GetOptions
   ropp_io_ascend
   ropp_io_occid
   ropp_io_read
   ropp_io_thin
   ropp_io_free
   PBOPEN
   PBWRITE
   PBCLOSE
   GTShdrCSN
   GTShdrIPH
   CalToJul
   Date_and_Time_UTC
   DateTimeOffset
   To_Lower
   File_Delete
   message
   message_set_routine

 MODULES
   ropp2bufr           - fixed parameter definitions & common routines
   ropp_io             - ROPP I/O file support
   ropp_io_types       - ROPP data type definitions
   DateTimeProgs       - Date & Time conversion routines
   DateTimeTypes       - Date & Time conversion definitions
   messages            - ROPP message library
   GTShdrs             - routines to add WMO/GTS routing header/trailer

 DEPENDENCIES
   ECMWF BUFR package  - BUFR kernel routines
   ROPP I/O library    - ROPP file I/O support
   ROPP Utils library  - ROPP utility routines
   netCDF library      - netCDF file support
\end{Verbatim}
\textbf{ENVIRONMENT VARIABLES:}\hspace{0.08in}\begin{Verbatim}
   BUFR_TABLES        - path for run-time files

 ERRORS
   Program (shell) return codes:
     0 = OK
    -1 = Occultation rejected as too old for GTS
     1 = I/O error
     2 = Memory allocation failure
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   A BUFR encoder for Radio Occultation data.
   Reads from one or more EUM netCDF 4 files and encodes data therein
   to one BUFR message per profile output to a single BUR file.
   Various options are provided to control the generation of GTS
   routing headers and rejection based on the age of the data
   and to skip encoding certain profile subsets and thinning (see Refs.3,4).
   BUFR tables and other run-time files are found via the environment
   variable 'BUFR_TABLES'.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1) ROPP User Guide - Part I
      SAF/ROM/METO/UG/ROPP/002
   2) WMO FM94 (BUFR) Specification for ROM SAF Processed Radio
      Occultation Data.
      SAF/ROM/METO/FMT/BUFR/001
   3) Monodimensional data thinning for GPS radio occultations
      SAF/GRAS/METO/ALG/ROPP/001
   4) ROPP thinner algorithm
      SAF/GRAS/METO/REP/GSR/8
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
   ropp2bufr(1), bufr2ropp(1)
\end{Verbatim}
\section{Programs/eum2ropp}
\textsl{[ Programs ]}

\label{ch:robo83}
\label{ch:Programs_eum2ropp}
\index{unsorted!eum2ropp}\index{Programs!eum2ropp}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   eum2ropp
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Converts a EUMETSAT netCDF 4 level 1B file into an
   ROPP netCDF file with optional thinning

   > eum2ropp ip_file [ip_file...] [-o op_file] [-p lev_file]
                       [-m] [-a] [-u] [-i] [-d] [-h] [-v]
\end{Verbatim}
\textbf{ARGUMENTS:}\hspace{0.08in}\begin{Verbatim}
   ip_file - one or more EUM netCDF level 1B files
             There is no default for this argument.
\end{Verbatim}
\textbf{OPTIONS:}\hspace{0.08in}\begin{Verbatim}
   -o specifies an output file name - mandatory argument if used
     (default: name generated from the file header)
   -p specifies a sampling levels control file for profile thinning
      or a positive integer representing the maximum no. of levels
      for implied SAMPLE mode (default: no thinning)
   -m causes the output into a multifile (i.e., a single ROPP netCDF
      file holding multiple profiles).
   -a appends to an already existing file (default is to
      overwrite an already existing file) (-a implies -m)
   -u leaves profiles untouched (do not sort or thin input data).
      -p option is ignored if -u present. (Default: sort profiles
      into ascending order, thin according to -p option)
   -i thins on impact altitudes (IP - RoC - undulation)
   -d  writes additional diagnostic information to stdout
   -h (or ?) causes only summary help to be output
   -r resolution_group name of level 1B file, default thinned
   -l get also level 1A data into ROPP netCDF file
   -v outputs program version ID
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_nrec
   ropp_io_read
   ropp_io_write
   ropp_io_occid
   ropp_io_ascend
   ropp_io_thin
   ropp_io_rangecheck
   ropp_io_version
   FileDelete
   message
   message_set_routine
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Converts a EUMETSAT netCDF 4 level 1B file into an
   ROPP netCDF file with optional thinning
   Only single input profiles can be processed currently but multifiles
   can be written. Also allows thinning of data. Descending profiles
   are made ascending by default.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    eum2ropp(1)
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
   This is a trivial sample program showing a simple ROPP file I/O
   interface for illustrative purposes only; it is not intended to be
   a comprehensive or robust tool.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1. ROPP User Guide - Part I
      SAF/ROM/METO/UG/ROPP/002
   2. ROPP Thinner Algorithm.
      SAF/GRAS/METO/REP/GSR/008
\end{Verbatim}
\section{Programs/gfz2ropp}
\textsl{[ Programs ]}

\label{ch:robo84}
\label{ch:Programs_gfz2ropp}
\index{unsorted!gfz2ropp}\index{Programs!gfz2ropp}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   gfz2ropp
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Convert GFZ NRT DAT/DSC files to ROPP netCDF

   > gfz2ropp <gfzfile.dat> [-o opfile] [-d] [-h] [-v]
\end{Verbatim}
\textbf{ARGUMENTS:}\hspace{0.08in}\begin{Verbatim}
   gfzfile.dat - GFZ 'PD' or 'NRT' DAT (.dat) file containing Level 1b,2a,2b
                 RO profiles. May include a path. The companion DSC file
                 containing meta-data is assumed to be in the same path and
                 have the same name at the DAT file, but with a type of .dsc.
                 There is no default for this argument.
\end{Verbatim}
\textbf{OPTIONS:}\hspace{0.08in}\begin{Verbatim}
  -o  - specifies the output netCDF file name. The default name
        is the same as the DAT/DSC file name, but with a type of
        .nc and in the current working directory.
  -d - writes additional diagnostic information to stdout
  -h - help
  -v - version information
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   Pair of GFZ NRT .dat (profile) and .dsc (meta information)

 OUTPUTS
   ROPP netCDF file - As given with the -o option, or defaults to the
                      same path and file name as for input DAT file,
                      but with type .nc

 MODULES
   typesizes
   messages
   ropp_utils
   ropp_io_types
   ropp_io
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   usage
   ropp_io_init
   ropp_io_occid
   ropp_io_ascend
   ropp_io_write
   ropp_io_free
   ropp_io_version
   message
   message_set_routine
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Conversion from GFZ native-format GPSRO 'PD' (ROPP Level1a) or 'NRT'
   (ROPP Levels 1b,2a,2b) data to ROPP netCDF format. Input is the pair of
   DAT (data) & DCS (description) files; the profiles are taken from the
   former, and meta-data (non-profile header info) from the latter.
   The data is then written out to a ROPP-standard netCDF file in PWD.
   Only the name of the DAT file is given on the command line; the companion
   DSC file is assumed to be in the same path and have the same name at the
   DAT file, but with a type of .dsc.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1. ROPP User Guide - Part I.
      SAF/ROM/METO/UG/ROPP/002
\end{Verbatim}
\section{Programs/grib2bgrasc}
\textsl{[ Programs ]}

\label{ch:robo85}
\label{ch:Programs_grib2bgrasc}
\index{unsorted!grib2bgrasc}\index{Programs!grib2bgrasc}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   grib2bgrasc    (grib2bgrasc.f90)
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Extract RO background data from GRIB (ed 1 or 2) file(s) 
   and output in fortran namelist format.

   > grib2bgrasc grib_file -lat <lat> -lon <lon>
                 [-date <date>] [-time <time>] 
                 [-g grib_file2]
                 [-z grib_filez]
                 [-o <namelist_file>]
                 [-r <radius_of_curvature>]
                 [-u <undulation>]
                 [-d] [-h] [-v]
\end{Verbatim}
\textbf{ARGUMENTS:}\hspace{0.08in}\begin{Verbatim}
   grib_file  - GRIB file containing background fields.
   lat        - latitude (deg)
   lon        - longitude (deg)
\end{Verbatim}
\textbf{OPTIONS:}\hspace{0.08in}\begin{Verbatim}
   Option switches can be in any order and are case-insensitive;
   any space(s) between a switch and its (madatory) argument is
   optional.
     -g grib_file2.  Second GRIB file containing background fields, if time interpolation needed.
     -date <date> (yyyymmdd).  Date, if time interpolation needed.
     -time <time> (HHMM or HHMMSS).  Time, if time interpolation needed.
     -z grib_filez.  GRIB file containing surface geopotential, aka g_wmo*orography, if needed.
     -r <roc>. radius of curvature of tangent plane (m).
     -u <und>. Undulation at tangent point (m).
     -o <namelist_file> output file name
     -d to output additional diagnostics
     -h help
     -v version information
   Defaults:
     Input file name : required
     Output file name : $PWD/input_file.nml
 NOTE
   The environment variables GEOPOT_COEF and GEOPOT_CORR must be
   set appropriately if the user wants the undulation to be calculated.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   grib_files containing background fields in GRIB (ed 1 or 2) format.
     Each input file must contain {p*, phi*, T, q, Ak, Bk}.

 OUTPUTS
   Ascii file holding fortran namelist bgr_profile. 
     The output file name is optional.
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   IARGC
   message
   message_set_routine
   extract_prof_from_GRIB
   generate_GPH

 MODULES
   grib_api
   typesizes
   messages
   coordinates
   DateTimeProgs
   ropp_utils
   ropp_io

 DEPENDENCIES
   ECMWF GRIB package  - GRIB kernel routines
   ROPP Utils library  - ROPP utility routines
   The environment variables GEOPOT_COEF and GEOPOT_CORR must be 
     set appropriately if the user wants the undulation to be calculated.
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   A GRIB background data translator for Radio Occultation data.
   Generates one profile, in Fortran namelist format, from one GRIB file. 
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1) GRIB API
      https://software.ecmwf.int/wiki/display/GRIB/Home
   2) ROPP User Guide - Part 1: IO module
      SAF/ROM/METO/UG/ROPP/002
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
   grib2bgrasc(1)
\end{Verbatim}
\section{Programs/ropp2bufr\_ec}
\textsl{[ Programs ]}

\label{ch:robo86}
\label{ch:Programs_ropp2bufr_ec}
\index{unsorted!ropp2bufr\_ec}\index{Programs!ropp2bufr\_ec}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ropp2bufr    (ropp2bufr_mo.f90)
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Encode an ROPP file to WMO FM-94 (BUFR) [ECMWF library]

   > export BUFR_TABLES=bufr_directory_path
   > ropp2bufr ropp_file [ropp_file...] [-o bufr_file]
                         [-g[i]] [-s csn_file]
                         [-p thin_file] [-t time]
                         [-u] [-l] [-m] [-h|?] [-v] [-d]
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   ropp_file is the input file(s) which must be in ROPP netCDF
             format (See Ref.1)
 OUTPUTS
   bufr_file is the output file, which will contain one encoded
             BUFR message per input profile (See Ref.2)
             The output file name is optional, and if not specified,
             is generated from the occulation ID.
\end{Verbatim}
\textbf{OPTIONS:}\hspace{0.08in}\begin{Verbatim}
   Option switches can be in any order and are case-insensitive;
   any space(s) between a switch and its (madatory) argument is
   optional.
     -o  specifies the BUFR output file name
     -g  specifies that GTS routing headers/trailers are required
     -gi speciifes that GTS headers include a 10-byte leading size/type
         (required for some TCP/IP (FTP) implimentations for GTS)
     -s  specifies a channel sequence number file
     -p  specifies a thinning control file or max. no. of levels
     -t  specifies a time (age) rejection threshold
     -u  leave profiles unordered - disables the default re-ordering
         of output profiles to ascending.
         NB: using -u, profiles thinned using one of the interpolation methods
         will retain the order of the fixed levels in the control file; other
         methods will retain the ordering of the input profiles.
     -l  do not encode L1+L2 data (bending angle, Level 1b), if present
     -m  do not encode met.  data (geophysical, Level 2b,c), if present
     -d  to output additional diagnostics
     -h or ? to output summary help
     -v  to output program version ID
   Defaults
     Input file name         : ropp.nc
     Output file name        : <occid>.bufr
     GTS routing headers     : not generated
     Channel sequence        : initialised at 001
     Time threshold          : 00:00 (no cut-off) unless one of
                               -g options present, when 23:50
     Encode                  : all available Level 1b, 2b & 2c data
     Thinning                : sample to no more than 375 levels
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   IARGC
   ConvertROPPtoBUFR
   EncodeBUFR
   GetOptions
   ropp_io_ascend
   ropp_io_occid
   ropp_io_read
   ropp_io_thin
   ropp_io_free
   PBOPEN
   PBWRITE
   PBCLOSE
   GTShdrCSN
   GTShdrIPH
   CalToJul
   Date_and_Time_UTC
   DateTimeOffset
   To_Lower
   File_Delete
   message
   message_set_routine

 MODULES
   ropp2bufr           - fixed parameter definitions & common routines
   ropp_io             - ROPP I/O file support
   ropp_io_types       - ROPP data type definitions
   DateTimeProgs       - Date & Time conversion routines
   DateTimeTypes       - Date & Time conversion definitions
   messages            - ROPP message library
   GTShdrs             - routines to add WMO/GTS routing header/trailer

 DEPENDENCIES
   ECMWF BUFR package  - BUFR kernel routines
   ROPP I/O library    - ROPP file I/O support
   ROPP Utils library  - ROPP utility routines
   netCDF library      - netCDF file support
\end{Verbatim}
\textbf{ENVIRONMENT VARIABLES:}\hspace{0.08in}\begin{Verbatim}
   BUFR_TABLES        - path for run-time files

 ERRORS
   Program (shell) return codes:
     0 = OK
    -1 = Occultation rejected as too old for GTS
     1 = I/O error
     2 = Memory allocation failure
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   A BUFR encoder for Radio Occultation data.
   Reads from one or more ROPP netCDF files and encodes data therein
   to one BUFR message per profile output to a single BUR file.
   Various options are provided to control the generation of GTS
   routing headers and rejection based on the age of the data
   and to skip encoding certain profile subsets and thinning (see Refs.3,4).
   BUFR tables and other run-time files are found via the environment
   variable 'BUFR_TABLES'.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1) ROPP User Guide - Part I
      SAF/ROM/METO/UG/ROPP/002
   2) WMO FM94 (BUFR) Specification for ROM SAF Processed Radio
      Occultation Data.
      SAF/ROM/METO/FMT/BUFR/001
   3) Monodimensional data thinning for GPS radio occultations
      SAF/GRAS/METO/ALG/ROPP/001
   4) ROPP thinner algorithm
      SAF/GRAS/METO/REP/GSR/8
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
   ropp2bufr(1), bufr2ropp(1)
\end{Verbatim}
\section{Programs/ropp2bufr\_mo}
\textsl{[ Programs ]}

\label{ch:robo87}
\label{ch:Programs_ropp2bufr_mo}
\index{unsorted!ropp2bufr\_mo}\index{Programs!ropp2bufr\_mo}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ropp2bufr    (ropp2bufr_mo.f90)
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Encode an ROPP file to WMO FM-94 (BUFR) [MetDB library]

   > export BUFR_LIBRARY=bufr_directory_path
   > ropp2bufr ropp_file [ropp_file...] [-o bufr_file]
                         [-g[i]] [-s csn_file]
                         [-p thin_file] [-t time]
                         [-u] [-l] [-m] [-h|?] [-v] [-d]
\end{Verbatim}
\textbf{ARGUMENTS:}\hspace{0.08in}\begin{Verbatim}
   ropp_file - one or more ROPP netCDF files.
\end{Verbatim}
\textbf{OPTIONS:}\hspace{0.08in}\begin{Verbatim}
   Option switches can be in any order and are case-insensitive;
   any space(s) between a switch and its (madatory) argument is
   optional.
     -o  specifies the BUFR output file name
     -g  specifies that GTS routing headers/trailers are required
     -gi speciifes that GTS headers include a 10-byte leading size/type
         (required for some TCP/IP (FTP) implimentations for GTS)
     -s  specifies a channel sequence number file
     -p  specifies a thinning control file or max. no. of levels
     -t  specifies a time (age) rejection threshold
     -u  leave profiles unordered - disables the default re-ordering
         of output profiles to ascending.
         NB: using -u, profiles thinned using one of the interpolation methods
         will retain the order of the fixed levels in the control file; other
         methods will retain the ordering of the input profiles.
     -l  do not encode L1+L2 data (bending angle, Level 1b), if present
     -m  do not encode met.  data (geophysical, Level 2b,c), if present
     -d  to output additional diagnostics
     -h  help
     -v  version information
   Defaults
     Input file name         : ropp.nc
     Output file name        : <occid>.bufr
     GTS routing headers     : not generated
     Channel sequence        : initialised at 001
     Time threshold          : 00:00 (no cut-off) unless one of
                               -g options present, when 23:50
     Encode                  : all available Level 1b, 2b & 2c data
     Thinning                : sample to no more than 375 levels
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   ropp_file is the input file(s) which must be in ROPP netCDF
             format (See Ref.1)

 OUTPUTS
   bufr_file is the output file, which will contain one encoded
             BUFR message per input profile (See Ref.2)
             The output file name is optional, and if not specified,
             is generated from the occulation ID.
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   IARGC
   ConvertROPPtoBUFR
   EncodeBUFR
   GetOptions
   ropp_io_ascend
   ropp_io_occid
   ropp_io_read
   ropp_io_thin
   ropp_io_free
   ropp_io_version
   ConvertDescriptor
   METDB_COPEN
   METDB_CWRITE
   METDB_CCLOSE
   GTShdrCSN
   GTShdrIPH
   CalToJul
   DateTimeOffset
   To_Lower
   File_Delete
   message
   message_set_routine

 MODULES
   ropp2bufr           - fixed parameter definitions & common routines
   ropp_io             - ROPP I/O file support
   ropp_io_types       - ROPP data type definitions
   DateTimeProgs       - Date & Time conversion routines
   DateTimeTypes       - Date & Time conversion definitions
   BUFRutils           - BUFR utility routines
   messages            - ROPP message library
   GTShdrs             - routines to add WMO/GTS routing header/trailer

 DEPENDENCIES
   MetDB BUFR package  - BUFR kernel routines
   ROPP I/O library    - ROPP file I/O support
   ROPP Utils library  - ROPP utility routines
   netCDF library      - netCDF file support
\end{Verbatim}
\textbf{ENVIRONMENT VARIABLES:}\hspace{0.08in}\begin{Verbatim}
   BUFR_LIBRARY        - path for run-time files

 ERRORS
   Program (shell) return codes:
     0 = OK
    -1 = Occultation rejected as too old for GTS
     1 = I/O error
     2 = Memory allocation failure
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   A BUFR encoder for Radio Occultation data.
   Reads from one or more ROPP netCDF files and encodes data therein
   to one BUFR message per profile output to a single BUR file.
   Various options are provided to control the generation of GTS
   routing headers and rejection based on the age of the data
   and to skip encoding certain profile subsets and thinning (see Refs.3,4).
   BUFR tables and other run-time files are found via the environment
   variable 'BUFR_LIBRARY'.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1) ROPP User Guide - Part I
      SAF/ROM/METO/UG/ROPP/002
   2) WMO FM94 (BUFR) Specification for ROM SAF Processed Radio
      Occultation Data.
      SAF/ROM/METO/FMT/BUFR/001
   3) Monodimensional data thinning for GPS radio occultations
      SAF/GRAS/METO/ALG/ROPP/001
   4) ROPP thinner algorithm
      SAF/GRAS/METO/REP/GSR/8
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
   ropp2bufr(1), bufr2ropp(1)
\end{Verbatim}
\section{Programs/ropp2ropp}
\textsl{[ Programs ]}

\label{ch:robo88}
\label{ch:Programs_ropp2ropp}
\index{unsorted!ropp2ropp}\index{Programs!ropp2ropp}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ropp2ropp
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Copy/rename/range-check/reformat/thin/reorder a ROPP file

   > ropp2ropp ip_file [ip_file...] [-o op_file]
                       [-p lev_file] [-t 2d_bg_file]
                       [-i] [-u] [-m] [-a] [-l] [-d] [-h|?] [-v]
\end{Verbatim}
\textbf{ARGUMENTS:}\hspace{0.08in}\begin{Verbatim}
  ip_file - one or more ROPP netCDF files.
            In the special case of an input file name 'DUMMY', ropp2ropp
            will internally generate and output a dummy ROPP file
            filled with missing data flag values.
\end{Verbatim}
\textbf{OPTIONS:}\hspace{0.08in}\begin{Verbatim}
   -o specifies an output file name - mandatory argument if used
      (default: name generated from the occultation ID)
   -p specifies a sampling levels control file for profile thinning
      or a non-negative integer representing the maximum no. of levels
      for implied SAMPLE mode (default: '0' = no thinning)
   -t read two-dimensional background data
   -u 'unordered' - disables the default re-ordering of output
      profiles to ascending.
      NB: using -u, profiles thinned using one of the interpolation methods
      will retain the order of the fixed levels in the control file; other
      methods will retain the ordering of the input profiles.
   -i thins on impact altitudes (IP - RoC - undulation)
   -m causes the output into a multifile (i.e., a single netCDF file
      holding multiple profiles).
   -a appends to an already existing file (default is to
      overwrite an already existing file) (-a implies -m)
   -l outputs a brief contents listing (OccID & lat/lon) only
      to stdout - suppresses ROPP file o/p
   -d outputs a sampled dump of the file header to stdout
      plus other diagnostics
   -h help
   -v version information
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   ropp2ropp is a general-purpose ROPP file conversion tool with
   range-checking and thinning facility.
   It can 'copy/rename' one netCDF ROPP file to another.
   Multiple input files can be processed either by explicitly specifying
   more than one file name on the command line and/or by wildcards.
   Existing multifiles can be split into single files. Profiles are by
   default ordered to be in ascending heights but this can be disabled.
   Profiles can optionally be thinned.

 MODULES
   ropp_utils
   ropp_io_types
   ropp_io
   ncdf
   DateTimeProgs
   DateTimeTypes
   messages
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   Usage
   ropp_io_ascend
   ropp_io_nrec
   ropp_io_read
   ropp_io_write
   ropp_io_occid
   ropp_io_thin
   ropp_io_free
   ropp_io_rangecheck
   ropp_io_version
   MonthOfYear
   File_Delete
   message
   message_set_routine
   To_Lower
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1. ROPP User Guide - Part I
      SAF/ROM/METO/UG/ROPP/002
   2. ROPP Thinner Algorithm
      SAF/GRAS/METO/REP/GSR/008
\end{Verbatim}
\section{Programs/test2ropp}
\textsl{[ Programs ]}

\label{ch:robo89}
\label{ch:Programs_test2ropp}
\index{unsorted!test2ropp}\index{Programs!test2ropp}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   test2ropp
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Tool to generate (non-scientific) test data in ROPP netCDF format

   > test2ropp test [-o opfile] [-n nsamp] [-d] [-h] [-v]
\end{Verbatim}
\textbf{ARGUMENTS:}\hspace{0.08in}\begin{Verbatim}
   test - one of the supported test data types MISSING, VALID, INVALID,
          BADPROF or MISPROF
\end{Verbatim}
\textbf{OPTIONS:}\hspace{0.08in}\begin{Verbatim}
   -n sets the number of samples in the profile (default: 247)
   -o specifies an output file name - mandatory argument if used
     (default: name generated from the occultation ID. NB this
      will always be a valid string for a file name even if the
      individual header elements are invalid)
   -d outputs a sampled dump of the file header to stdout
      plus other diagnostics
   -h help
   -v version information
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   test2ropp is a tool to generate (non-scientific) test data in ROPP format.
   The supported test data types are:
    MISSING : generate a set of test data in which all parameters are
              set to missing data values.
    VALID   : generate a set of test data in which all parameters are
              set to random, but valid (within range), data values.
    INVALID : generate a set of test data in which all parameters are
              set to random, out-of-range, data values
    BADPROF : generate a set of test data in which all time and vertical
              coordinates are increasing within valid ranges, but all
              observed profile data is randomly invalid and all sigmas &
              quality values are set missing. Header data is randomly valid.
    MISPROF : As BADPROF except a range check is performed to output observed
              profiles as missing.
    The test type is case-insensitive.
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   test2ropp_random
   ropp_io_init
   ropp_io_write
   ropp_io_occid
   ropp_io_free
   ropp_io_version
   MonthOfYear
   messages
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   test2ropp is a tool to generate (non-scientific) test data
   in ROPP format.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1. ROPP User Guide - Part I
      SAF/ROM/METO/UG/ROPP/002
\end{Verbatim}
\subsection{test2ropp/test2ropp\_badprof}
\textsl{[ test2ropp ]}
\textsl{[ Programs ]}

\label{ch:robo104}
\label{ch:test2ropp_test2ropp_badprof}
\index{unsorted!test2ropp\_badprof}\index{Programs!test2ropp\_badprof}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   test2ropp_badprof - generate a bad profile with sensible vertical
                       coordinates, but random, invalid, profile values
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   USE ropp_io_types
   TYPE(ROprof) :: ROdata
   CALL test2ropp_badprof(ROdata)

 INPUT
   ROdata  dtyp  ROPP structure
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
   ROdata  dtyp  ROPP structure
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Fills a ROPP structure with (more-or-less) sensible time & vertical
   coordinate parameter values, but the observed profile is filled with
   random values with a linear PDF, but all having out-of-range values
   (randomly positive or negative where appropriate). Values will
   still be within sensible bounds (ie not exceeding the missing data
   flag values. Header values are filled with valid values as per
   test2ropp_valid. Sigma and Quality parameters are left missing.
\end{Verbatim}
\subsection{test2ropp/test2ropp\_invalid}
\textsl{[ test2ropp ]}
\textsl{[ Programs ]}

\label{ch:robo105}
\label{ch:test2ropp_test2ropp_invalid}
\index{unsorted!test2ropp\_invalid}\index{Programs!test2ropp\_invalid}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   test2ropp_invalid - generate random, invalid, test data
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   USE ropp_io_types
   TYPE(ROprof) :: ROdata
   CALL test2ropp_invalid(ROdata)

 INPUT
   ROdata  dtyp  ROPP structure
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
   ROdata  dtyp  ROPP structure
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Fills a ROPP structure with random values with a linear PDF, but
   all having out-of-range values (randomly positive or negative
   where appropriate). Values will still be within sensible bounds
   (ie not exceeding the missing data flag values or text file field
   widths, or printable characters for string parameters).
\end{Verbatim}
\subsection{test2ropp/test2ropp\_valid}
\textsl{[ test2ropp ]}
\textsl{[ Programs ]}

\label{ch:robo106}
\label{ch:test2ropp_test2ropp_valid}
\index{unsorted!test2ropp\_valid}\index{Programs!test2ropp\_valid}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   test2ropp_valid - generate random, valid, test data
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   USE ropp_io_types
   TYPE(ROprof) :: ROdata
   CALL test2ropp_valid(ROdata)

 INPUT
   ROdata  dtyp  ROPP structure
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
   ROdata  dtyp  ROPP structure
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Fills a ROPP structure with random values with a linear PDF.
   All parameters will be within their valid ranges; string
   parameters will have a randomly chosen sensible option taken
   from a list.
\end{Verbatim}
\section{Programs/ucar2ropp}
\textsl{[ Programs ]}

\label{ch:robo90}
\label{ch:Programs_ucar2ropp}
\index{unsorted!ucar2ropp}\index{Programs!ucar2ropp}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ucar2ropp
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Converts a UCAR 'atmPrf', 'atmPhs', 'sonPrf', 'ecmPrf', 'ncpPrf', or
  'gfsPrf' netCDF file of COSMIC, CHAMP, C/NOFS or SAC-C data into an
   ROPP netCDF file with optional thinning

   > ucar2ropp ip_file [ip_file...] [-o op_file] [-p lev_file]
                       [-m] [-a] [-u] [-i] [-d] [-h] [-v]
\end{Verbatim}
\textbf{ARGUMENTS:}\hspace{0.08in}\begin{Verbatim}
   ip_file - one or more UCAR netCDF files of type 'atmPrf', 'atmPhs',
             'sonPrf', 'ecmPrf', 'ncpPrf' or 'gfsPrf'.
             There is no default for this argument.
\end{Verbatim}
\textbf{OPTIONS:}\hspace{0.08in}\begin{Verbatim}
   -o specifies an output file name - mandatory argument if used
     (default: name generated from the file header)
   -p specifies a sampling levels control file for profile thinning
      or a positive integer representing the maximum no. of levels
      for implied SAMPLE mode (default: no thinning)
   -m causes the output into a multifile (i.e., a single ROPP netCDF
      file holding multiple profiles).
   -a appends to an already existing file (default is to
      overwrite an already existing file) (-a implies -m)
   -u leaves profiles untouched (do not sort or thin input data).
      -p option is ignored if -u present. (Default: sort profiles
      into ascending order, thin according to -p option)
   -i thins on impact altitudes (IP - RoC - undulation)
   -d  writes additional diagnostic information to stdout
   -h (or ?) causes only summary help to be output
   -v outputs program version ID
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_nrec
   ropp_io_read
   ropp_io_write
   ropp_io_occid
   ropp_io_ascend
   ropp_io_thin
   ropp_io_rangecheck
   ropp_io_version
   FileDelete
   message
   message_set_routine
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Converts a UCAR 'atmPrf', 'atmPhs', 'sonPrf', 'ecmPrf', 'ncpPrf', or
  'gfsPrf' netCDF file of COSMIC, CHAMP, C/NOFS or SAC-C data into an
   ROPP netCDF file.
   Only single input profiles can be processed currently but multifiles
   can be written. Also allows thinning of data. Descending profiles
   are made ascending by default.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ucar2ropp(1)
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
   This is a trivial sample program showing a simple ROPP file I/O
   interface for illustrative purposes only; it is not intended to be
   a comprehensive or robust tool.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1. ROPP User Guide - Part I
      SAF/ROM/METO/UG/ROPP/002
   2. ROPP Thinner Algorithm.
      SAF/GRAS/METO/REP/GSR/008
\end{Verbatim}
\section{Query/ncdf\_getgroupid}
\textsl{[ Functions ]}

\label{ch:robo91}
\label{ch:Query_ncdf_getgroupid}
\index{unsorted!ncdf\_getgroupid}\index{Functions!ncdf\_getgroupid}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getgroupid - Return group ID from a variable name.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    status = ncdf_getgroupid(ncid_local, name, vname, groupid, havegroup)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This function returns the actual variable name (sans '/'s) and
    group ID, if applicable.  (Groups are identified like directories, with /.)
    If no / is present, the input name is copied to vname and havegroup is returned .FALSE.

    Note that, if netCDF-4 is not installed, the ncdf_getgroupid_n3.f90 version
    of ncdf_getgroupid.f90 will be compiled.  This will result in havegroup being set to .FALSE. 
    and groupid being set to ncid_local.  Otherwise ncdf_getgroupid_n4.f90 will be
    compiled, which has the functionality above.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    INTEGER              :: ncid_local  -  Netcdf file ID
    CHARACTER (len = *)  :: name        -  Full variable name, including '/'s if applicable
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    CHARACTER (len = *)  :: vname       -  Actual variable name, stripped of /
    INTEGER              :: groupid     -  Group ID (if applicable)
    LOGICAL              :: havegroup   -  Has a group been found?
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    To find the netcdf group ID of the variable 
    '/ropp/is/great' in the file 'yes_it_is.nc':
    status = nf90_open('yes_it_is.nc', nf90_share, ncid_local)
    status = ncdf_getgroupid(ncid_local, '/ropp/is/great', vname, groupid, havegroup)

    The variable itself can then be obtained with something like:
    ncid_local = groupid
    status = nf90_inq_varid(ncid_local, var_name, var_id)
    status = nf90_get_var(ncid_local, var_id, var_values)
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getsize
    ncdf_getatt
    ncdf_getshape
    ncdf_getvar
    ncdf_getatt_alloc
    ncdf_getnrec
    ncdf_getvar_alloc
\end{Verbatim}
\section{Query/ncdf\_getnrec}
\textsl{[ Functions ]}

\label{ch:robo92}
\label{ch:Query_ncdf_getnrec}
\index{unsorted!ncdf\_getnrec}\index{Functions!ncdf\_getnrec}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getnrec - Return number of records in a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    n_unlimited = ncdf_get_getnrec(ncfile = ..., ncid = ...)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This function returns the number of records (i.e., the maximum
    value of a record number used for writing any variable along an
    unlimited dimension) in a netCDF data file. Error handling is
    done inside the routine.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    character(len = *) :: ncfile    Name of netCDF data file.
    integer            :: ncid      netCDF id.

    Note that all arguments are optional.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    integer            :: n_unlimited
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    Assume that you want to know how many records were already written
    a data file and append it with another record. Try

       use ncdf
         ...
       integer              :: n
         ...
       call ncdf_open('test.nc')
         ...
       n = ncdf_getnrec()
       call ncdf_putvar('variable', data, rec = n + 1)
         ...
       call ncdf_close()
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getshape
    ncdf_getsize
\end{Verbatim}
\section{Query/ncdf\_getshape}
\textsl{[ Subroutines ]}

\label{ch:robo93}
\label{ch:Query_ncdf_getshape}
\index{unsorted!ncdf\_getshape}\index{Subroutines!ncdf\_getshape}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getshape - Return the shape of a variable in a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_getshape(varname, shape, ncfile = ..., ncid = ...)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine gets the shape (i.e., number of dimensions) from
    a variable in a netCDF data file. Error handling is done inside
    the routine.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    character(len = *) :: varname   Name of variable.
    integer            :: shape     Shape of variable.
    character(len = *) :: ncfile    Name of netCDF data file.
    integer            :: ncid      netCDF id.

    Note that all but the first two variables are optional.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    integer            :: shape
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    Assume that you want to know the shape of a variable named 'alpha_b'
    contained in a netCDF data file. Try

       use ncdf
         ...
       integer         :: shape
         ...
       call ncdf_open('test.nc')
         ...
       call ncdf_getshape('alpha_b', shape)
         ...
       call ncdf_close()
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getsize
\end{Verbatim}
\section{Query/ncdf\_getsize}
\textsl{[ Subroutines ]}

\label{ch:robo94}
\label{ch:Query_ncdf_getsize}
\index{unsorted!ncdf\_getsize}\index{Subroutines!ncdf\_getsize}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getsize - Return the size(s) of a variable in a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_getsize(varname, size [, dim], ncfile = ..., ncid = ...)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine gets the size of a variable (i.e., the number
    of elements, or, if dim is specified, the number of elements
    along the specified dimension) or all sizes of the variable
    (i.e. number of elements along all dimensions in an array) from
    this variable in a netCDF data file.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    character(len = *) :: varname   Name of variable.
    integer            :: dim       Dimension (starting with 1).
    character(len = *) :: ncfile    Name of netCDF data file.
    integer            :: ncid      netCDF id of the netCDF data file.

    Note that all but the first two arguments are optional.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    integer                :: size
      - or -
    integer, dimension(:)  :: size
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    Assume that you want to know the size of a 1d netCDF variable named
    'data' and read that variable into an appropriately allocated array.
    Try

       use ncdf
         ...
       integer                             :: n
         ...
       real(wp), dimension(:), allocatable :: data
         ...
       call ncdf_open('test.nc')
         ...
       call ncdf_getsize('data', n)
         ...
       allocate(data(n))
       call ncdf_getvar('data', data)
         ...
       call ncdf_close()
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The routine, when called with a scalar size argument, will return the
    total number of elements of a netCDF variable. To get the number of
    elements along an individual dimension (if the variable has more than
    one dimension), either call ncdf_getsize with the optional 'dim = '
    argument, or with size being an integer array which will contain the
    corresponding length for each dimension.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getshape
\end{Verbatim}
\section{Reading/ropp\_io\_read}
\textsl{[ Subroutines ]}

\label{ch:robo95}
\label{ch:Reading_ropp_io_read}
\index{unsorted!ropp\_io\_read}\index{Subroutines!ropp\_io\_read}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_read - Read an ROPP data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ropp_io
    type(ROprof) :: ro_data
      ...
    call ropp_io_read(data, file [, centre= ..., rec=..., ierr= ..., ranchk=...])
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine reads RO event data from a specified file. The file
    must conform to the ROPP (netCDF) data format
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    data    dtyp   one of the data types defined in ropp_io_types:
                    e.g.  ROprof
    file    chr    name of input file
    centre  string centre identifier (optional), e.g. UCAR
    rec     int    record number (optional, default 1)
    ranchk  log    range check flag (optional) Valid values are:
                    - .T. to perform a range check after input (default) or
                    - .F. to skip range checking
                   This flag should normally not be used or set to default .T.;
                   it is intended for use only when invalid data is explicitly
                   required to survive from the input netCDF file, such as when
                   reading invalid data for testing application Q/C.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    ierr  int    exit I/O code;
                    -  0 = ok
                    - -1 = unexpected EOF
                    - I/O error (system dependent or as obtained from netCDF)
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    If ierr is not given, the routine will abort in case of an error.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ropp_io
    ropp_io_types
    ropp_io_write
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_read_ncdf_get
\end{Verbatim}
\section{ropp2bufr/ropp2bufr}
\textsl{[ Modules ]}

\label{ch:robo102}
\label{ch:ropp2bufr_ropp2bufr}
\index{unsorted!ropp2bufr}\index{Modules!ropp2bufr}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ropp2bufr    (ropp2bufr_mod.f90)
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Module defining fixed values & subroutines/functions for the
   ropp2bufr main program (ECMWF or MetDB versions)

   USE ropp2bufr
\end{Verbatim}
\textbf{USED BY:}\hspace{0.08in}\begin{Verbatim}
   ropp2bufr   (ropp2bufr_ec or ropp2bufr_mo)
\end{Verbatim}
\subsection{ropp2bufr/ConvertCodes}
\textsl{[ ropp2bufr ]}
\textsl{[ Subroutines ]}

\label{ch:robo96}
\label{ch:ropp2bufr_ConvertCodes}
\index{unsorted!ConvertCodes}\index{Subroutines!ConvertCodes}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ConvertCodes
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
  Convert header codes between ROPP and BUFR

    USE ropp_io_types
    TYPE (roprof) rodata
    INTEGER :: gclass,gcode,lcode,icode,ocode,scode,bcode,ind
    CHARACTER (LEN=4) :: ccode
    ind = 1 ! to convert ROPP-->BUFR, ind = -1 for BUFR-->ROPP
    CALL convertcodes(rodata,&
                      gclass,gcode,lcode,icode,ocode,scode,ccode,bcode,&
                      ind)
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   ROdata  dtyp  RO data structure                     [ind>0]
   Gclass   int  GNSS code (Satellite Class)           [ind<=0]
   Gcode    int  GNSS PRN  (Platform Tx ID)            [ind<=0]
   Lcode    int  LEO  code (Satellite ID)              [ind<=0]
   Icode    int  Instrument code (Instrument ID)       [ind<=0]
   Ocode    int  Originating (processing) Centre code  [ind<=0]
   Scode    int  Originating Sub-centre code           [ind<=0]
   Ccode    chr  Originating (GTS) centre ICAO code    [ind<=0]
   Bcode    int  Background generating centre code     [ind<=0]
   ind      int  ROPP-->BUFR if >0, else BUFR-->ROPP

 OUTPUTS
   ROdata  dtyp  RO data structure                     [ind<=0]
   Gclass   int  GNSS code (Satellite Class)           [ind>0]
   Gcode    int  GNSS PRN  (Platform Tx ID)            [ind>0]
   Lcode    int  LEO  code (Satellite ID)              [ind>0]
   Icode    int  Instrument code (Instrument ID)       [ind>0]
   Ocode    int  Originating (processing) Centre code  [ind>0]
   Scode    int  Originating Sub-centre code           [ind>0]
   Ccode    chr  Originating (GTS) centre ICAO code    [ind>0]
   Bcode    int  Background generating centre code     [ind>0]

 MODULES
   messages    - ROPP message library
   ropp_utils  - ROPP utilities
   ropp_io     - ROPP file I/O support
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   GETENV
   Get_IO_Unit
   message
   message_get_routine
   message_set_routine
\end{Verbatim}
\textbf{CALLED BY:}\hspace{0.08in}\begin{Verbatim}
   ConvertBUFRtoROPP
   ConvertROPPtoBUFR

 FILES
   roppbufrcodes.nl  - in path BUFR_TABLES, BUFR_LIBRARY or PWD
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Converts from character-based codes (as defined for ROPP) to numeric codes
   suitable for BUFR encoding, if ind>0, else vice-versa.
   The code conversion is driven by a set of look-up tables, which are read
   from a NAMELIST file 'roppbufrcodes.nl' which is expected in the directory
   path defined by at least one of the environment variables BUFR_TABLES
   (ECMWF), BUFR_LIBRARY (MetDB) or PWD (searched in that order).
   If this file cannot be found or opened, a warning is issued and an in-built
   default set of tables is used instead.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1. Manual on Codes: International Codes, Part B & Part C.
      WMO-No. 306, World Meteorological Organisation, Geneva.
      http://www.wmo.int/pages/prog/www/WMOCodes/VolumeI2.html
   2. Location Indicators. ICAO Document 7910/138
      ISBN 978-92-9231-677-8, Ed.138, December 2010.
\end{Verbatim}
\subsection{ropp2bufr/ConvertROPPtoBUFR}
\textsl{[ ropp2bufr ]}
\textsl{[ Subroutines ]}

\label{ch:robo97}
\label{ch:ropp2bufr_ConvertROPPtoBUFR}
\index{unsorted!ConvertROPPtoBUFR}\index{Subroutines!ConvertROPPtoBUFR}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ConvertROPPtoBUFR
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Convert ROPP data to BUFR specification

    USE ropp_io_types
    USE ropp2bufr
    TYPE (ROprof) rodata
    CHARACTER (LEN=4) :: origicao
    INTEGER :: origcentre, subcentre, nvalues, nrepfac, repfac(nr)
    REAL(dp):: values(ne)
    LOGICAL :: corronly
    CALL convertropptobufr ( rodata, corronly, &
                             origicao, origcentre, subcentre, &
                             values, nvalues, repfac, nrepfac )
   where
    ne is the max. number of elements (data items for BUFR)
    nr is the max. number of delayed replication factors
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   ROdata     dtyp  RO data - derived type
   CorrOnly    log  Flag for corrected Level 1b profile only

 OUTPUTS
   ROdata     dtyp  RO data - derived type (potentially modified)
   OrigICAO    chr  4-chr ICAO code associated with Orig.Centre
   OrigCentre  int  Originating Centre code value
   SubCentre   int  Originating subcentre (processing centre) code value
   Values     dflt  Array(ne) of converted values for BUFR encoder
   nValues     int  Total no. of values converted
   RepFac      int  Array of Replication Factors
   nRepFac     int  Total no. of Replication Factors

 MODULES
   ropp_io_types  - ROPP file I/O support
   ropp_utils     - ROPP utility functions & parameters
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   ConvertCodes
   message
   message_get_routine
   message_set_routine
\end{Verbatim}
\textbf{CALLED BY:}\hspace{0.08in}\begin{Verbatim}
   ropp2bufr
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Converts RO data to BUFR units, etc, and returns converted data as a plain
   1-D array. This procedure is mostly scaling and/or range changing (e.g
   longitude from 0-360 to +/-180deg, hPa to Pa).
   This routine also performs gross error checking, so that if data is not
   valid (not within nominal range of BUFR bit width) that data value is set
   "missing" in the output array.
   The delayed replication factor counts are also returned for use with
   the ECMWF BUFEN() encoder (not used with the MetDB ENBUFV4() encoder).
   The processing (originating) centre's code & sub-centre code are
   returned for insertion in BUFR Section 1, plus the ICAO Location
   Indicator code for optonal use in a GTS routing header.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   1) ROPP User Guide - Part I
      SAF/ROM/METO/UG/ROPP/002
   2) WMO FM94 (BUFR) Specification for ROM SAF Processed Radio
      Occultation Data. SAF/ROM/METO/FMT/BUFR/001
\end{Verbatim}
\subsection{ropp2bufr/EncodeBUFR\_ec}
\textsl{[ ropp2bufr ]}
\textsl{[ Subroutines ]}

\label{ch:robo98}
\label{ch:ropp2bufr_EncodeBUFR_ec}
\index{unsorted!EncodeBUFR\_ec}\index{Subroutines!EncodeBUFR\_ec}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   EncodeBUFR
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Encode converted RO data to BUFR message & write it out

    USE ropp2bufr
    INTEGER :: bufrunit, csn, origcentre, subcentre
    INTEGER :: nobs, gtshdrtype, lenmsg, repfac(nrepfac)
    REAL(dp) :: values(nvalues)
    CHARACTER (LEN=4) :: origicao
    CALL encodebufr ( bufrunit, csn, &
                      origicao, origcentre, subcentre, &
                      values, nvalues, repfac, nrepfac, &
                      gtshdrtype, lenmsg )
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   BUFRunit    int  Output BUFR file unit
   CSN         int  Channel sequence number (001-999)
   OrigICAO    chr  4-chr ICAO location indicator for originator centre
   OrigCentre  int  Originator centre BUFR common code value
   SubCentre   int  Processing centre code value
   Values     dflt  Array of converted values for BUFR encoder
   nValues     int  No. of values to be encoded from Values array
   RepFac      int  Array of Replication Factors
   nRepFac     int  No. of Replication Factors
   GTShdrType  int  GTS header type indicator:
                     0: no headers
                     1: ARH
                     2: IPH + ARH

 OUTPUTS
   CSN         int  Updated channel sequence number (001-999)
   LenMSG      int  No. of bytes in BUFR message (including any IPH+ARH)
                    Returns zero if encoding or I/O error

 DEPENDENCIES:
   ECMWF BUFR package  - BUFR kernel routines
   GTShdrs             - routines to add WMO/GTS routing header/trailer
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   GTShdrIPH
   GTShdrARH
   GTShdrEOM
   BUFREN
   SBYTES
   PBWRITE
\end{Verbatim}
\textbf{CALLED BY:}\hspace{0.08in}\begin{Verbatim}
   ropp2bufr
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Encodes data in array "Values" (pre-converted to BUFR standard) to a BUFR
   message, and (with any optional IPH, ARH and EOM) ships it out to the file
   pre-opened on "BUFRunit". The data in the array must be consistent with the
   master descriptor sequence "ROdescr"
   On return, "LenMSG" gives the total number of bytes written out (BUFR
   message plus any ARH and IPH); or zero if any encoding or I/O error.
   An optional GTS Abbreviated Routing Header (ARH) is pre-pended and a
   trailer End-of-Message (EOM) appended) if GTShdrType=1. Further, an 8-byte
   length + 2-byte data type header is output first if GTShdrType=2, for
   compatability with GTS transmission via TCP/IP (FTP). In this case, a dummy
   IPH must be written after the last BUFR message, before closing the file.
   No headers are generated at all if GTShdrType is not 1 or 2.

 REFERENCE
   Dragosavac, Milan (2008) "BUFR User's Guide".
   ECMWF Operations Department Technical Note, August 2008.
\end{Verbatim}
\subsection{ropp2bufr/EncodeBUFR\_ec}
\textsl{[ ropp2bufr ]}
\textsl{[ Subroutines ]}

\label{ch:robo99}
\label{ch:ropp2bufr_EncodeBUFR_ec}
\index{unsorted!EncodeBUFR\_ec}\index{Subroutines!EncodeBUFR\_ec}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   EncodeBUFR
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Encode converted RO data to BUFR message & write it out

    USE ropp2bufr
    INTEGER :: bufrunit, csn, origcentre, subcentre
    INTEGER :: nobs, gtshdrtype, lenmsg, repfac(nrepfac)
    REAL(dp) :: values(nvalues)
    CHARACTER (LEN=4) :: origicao
    CALL encodebufr ( bufrunit, csn, &
                      origicao, origcentre, subcentre, &
                      values, nvalues, repfac, nrepfac, &
                      gtshdrtype, lenmsg )
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   BUFRunit    int  Output BUFR file unit
   CSN         int  Channel sequence number (001-999)
   OrigICAO    chr  4-chr ICAO location indicator for originator centre
   OrigCentre  int  Originator centre BUFR common code value
   SubCentre   int  Processing centre code value
   Values     dflt  Array of converted values for BUFR encoder
   nValues     int  No. of values to be encoded from Values array
   RepFac      int  Array of Replication Factors
   nRepFac     int  No. of Replication Factors
   GTShdrType  int  GTS header type indicator:
                     0: no headers
                     1: ARH
                     2: IPH + ARH

 OUTPUTS
   CSN         int  Updated channel sequence number (001-999)
   LenMSG      int  No. of bytes in BUFR message (including any IPH+ARH)
                    Returns zero if encoding or I/O error

 DEPENDENCIES:
   ECMWF BUFR package  - BUFR kernel routines
   GTShdrs             - routines to add WMO/GTS routing header/trailer
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   GTShdrIPH
   GTShdrARH
   GTShdrEOM
   BUFREN
   SBYTES
   PBWRITE
\end{Verbatim}
\textbf{CALLED BY:}\hspace{0.08in}\begin{Verbatim}
   ropp2bufr
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Encodes data in array "Values" (pre-converted to BUFR standard) to a BUFR
   message, and (with any optional IPH, ARH and EOM) ships it out to the file
   pre-opened on "BUFRunit". The data in the array must be consistent with the
   master descriptor sequence "ROdescr"
   On return, "LenMSG" gives the total number of bytes written out (BUFR
   message plus any ARH and IPH); or zero if any encoding or I/O error.
   An optional GTS Abbreviated Routing Header (ARH) is pre-pended and a
   trailer End-of-Message (EOM) appended) if GTShdrType=1. Further, an 8-byte
   length + 2-byte data type header is output first if GTShdrType=2, for
   compatability with GTS transmission via TCP/IP (FTP). In this case, a dummy
   IPH must be written after the last BUFR message, before closing the file.
   No headers are generated at all if GTShdrType is not 1 or 2.

 REFERENCE
   Dragosavac, Milan (2008) "BUFR User's Guide".
   ECMWF Operations Department Technical Note, August 2008.
\end{Verbatim}
\subsection{ropp2bufr/EncodeBUFR\_mo}
\textsl{[ ropp2bufr ]}
\textsl{[ Subroutines ]}

\label{ch:robo100}
\label{ch:ropp2bufr_EncodeBUFR_mo}
\index{unsorted!EncodeBUFR\_mo}\index{Subroutines!EncodeBUFR\_mo}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   EncodeBUFR
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Encode converted RO data to BUFR message & write it out

    USE ropp2bufr
    INTEGER :: bufrunit, csn, origcentre, subcentre
    INTEGER :: nobs, ndescr, gtshdrtype, lenmsg
    INTEGER :: descr(nd)
    REAL    :: values(ne,no)
    CHARACTER (LEN=4) :: origicao
    CALL encodebufr ( bufrunit, csn, &
                      origicao, origcentre, subcentre, &
                      descr, ndescr, values, nobs, &
                      gtshdrtype, lenmsg )
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   BUFRunit    int  Output BUFR file unit
   CSN         int  Channel sequence number (001-999)
   OrigICAO    chr  4-chr ICAO location indicator for originator centre
   OrigCentre  int  Originator centre BUFR common code value
   SubCentre   int  Processing centre code value
   Descr       int  Array of descriptors for type
   nDescr      int  No. of initial descriptors in descr
   Values      flt  Array(ne) of converted values for BUFR encoder
   nObs        int  No. of observations
   GTShdrType  int  GTS header type indicator:
                     0: no headers
                     1: ARH
                     2: IPH + ARH

 OUTPUTS
   CSN         int  Updated channel sequence number (001-999)
   Descr       int  Array of expanded descriptors
   nDescr      int  No. of expanded descriptors in descr
   LenMSG      int  No. of bytes in BUFR message (including any IPH+ARH)
                    Returns zero if encoding or I/O error

 DEPENDENCIES:
   MetDB BUFR package  - BUFR kernel routines
   GTShdrs             - routines to add WMO/GTS routing header/trailer
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   GTShdrIPH
   GTShdrARH
   GTShdrEOM
   ENBUFV4
   METDB_CWRITE
\end{Verbatim}
\textbf{CALLED BY:}\hspace{0.08in}\begin{Verbatim}
   ropp2bufr
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Encodes data in array "Values" (pre-converted to BUFR standard) to a BUFR
   message, and (with any optional IPH, ARH and EOM) ships it out to the file
   pre-opened on "BUFRunit". The data in the array must be consistent with the
   master descriptor sequence in "Desc(1)". On exit, Descr will contain an
   updated nDesc expanded descriptor list, so this array should be sized to
   the maximum expected expansion.
   On return, "LenMSG" gives the total number of bytes written out (BUFR
   message plus any ARH and IPH); or zero if any encoding or I/O error.
   An optional GTS Abbreviated Routing Header (ARH) is pre-pended and a
   trailer End-of-Message (EOM) appended) if GTShdrType=1. Further, an 8-byte
   length + 2-byte data type header is output first if GTShdrType=2, for
   compatability with GTS transmission via TCP/IP (FTP). In this case, a dummy
   IPH must be written after the last BUFR message, before closing the file.
   No headers are generated at all if GTShdrType is not 1 or 2.

 REFERENCE
   MetDB Technote 1: Decoding and Encoding BUFR messages
   File metdb/dmtn1.html in MetDB BUFR library package
\end{Verbatim}
\subsection{ropp2bufr/GetOptions}
\textsl{[ ropp2bufr ]}
\textsl{[ Subroutines ]}

\label{ch:robo101}
\label{ch:ropp2bufr_GetOptions}
\index{unsorted!GetOptions}\index{Subroutines!GetOptions}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   GetOptions
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   Get command line information & options or set defaults

    USE ropp2bufr
    CHARACTER (LEN=100) :: roppdsn(100), bufrdsn, csndsn
    INTEGER :: nfiles, gtshdrtype, rejtimediff
    LOGICAL :: corronly, nomet, unordered
    CALL getOptions ( roppdsn, nfiles, bufrdsn, csndsn, thindsn, &
                      gtshdrtype, rejtimediff, &
                      corronly, nomet, unordered, resolution )
   On command line:
   > ropp2bufr ropp_file [ropp_file...] [-o bufr_file]
                         [-g[n]] [-s seq_file]
                         [-p thin_file] [-t time] 
                         [-u] [-l] [-m] [-h|?] [-v] [-d]
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   None

 OUTPUTS
   ROPPdsn      chr  ROPP input file name(s)
   nfiles       int  No. of ROPP input files
   BUFRdsn      chr  BUFR output file name
   CSNdsn       chr  Channel sequence number file name
   Thindsn      chr  Thinning control file name
   GTShdrType   int  GTS header type code
   RejTimeDiff  int  Rejection time threshold (minutes)
   CorrOnly     log  L1+L2 skip flag
   nomet        log  Met data skip flag
   unordered    log  Disable profile ordering flag
   resolution   chr  resolution group to use in EUM netCDF 4 files
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   Usage
   message
   IARGC
   GETARG
\end{Verbatim}
\textbf{CALLED BY:}\hspace{0.08in}\begin{Verbatim}
   ropp2bufr

 MODULES
   DateTimeTypes   - Date & Time conversion definitions
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Provides a command line interface for the ROPP-to-BUFR
   encoder application. See comments for main program ropp2bufr
   for the command line details.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
   ropp2bufr(1), eum2bufr(1)
\end{Verbatim}
\subsection{ropp2bufr/Usage}
\textsl{[ ropp2bufr ]}
\textsl{[ Subroutines ]}

\label{ch:robo103}
\label{ch:ropp2bufr_Usage}
\index{unsorted!Usage}\index{Subroutines!Usage}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   Usage

 SYNOPIS
   USE ropp2bufr
   CALL Usage()
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   None

 OUTPUTS
   Summary usage text to stdout
\end{Verbatim}
\textbf{CALLED BY:}\hspace{0.08in}\begin{Verbatim}
   GetOptions
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   Prints a summary of program usage (help) to stdout.
\end{Verbatim}
\section{Thin/ropp\_io\_thin}
\textsl{[ Subroutines ]}

\label{ch:robo107}
\label{ch:Thin_ropp_io_thin}
\index{unsorted!ropp\_io\_thin}\index{Subroutines!ropp\_io\_thin}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_thin - Thin RO profiles
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   CALL ropp_io_thin ( ROdata, ThinFile[, impactalt=..][, ranchk=..] )

 INPUT
   ROdata     struc  RO profile structure (full profiles)
   ThinFile   chr    path/name of a file containing thinning
                     control information or a non-negative integer
                     representing the max. no. of points to thin
                     by sub-sampling. If input name is blank
                     or "0", no thinning is attempted
   impactalt   log   flag for thinning on impact altitudes
                     .T. to thin on impact altitudes
                     (= impact parameter - radius of curvature - undulation)
                     .F. to thin on impact heights (default)
                     (= impact parameter - radius of curvature)
   ranchk     log    range check flag (optional) Valid values are:
                     .T. to perform a range check before & after thinning
                         (default) or
                     .F. to skip range checking
                     This flag should not normally be used or if present, be
                     set to default .T.. It is intended for use only when
                     deliberately invalid data is explicitly required to
                     survive thinning, such as when testing the thinner
                     itself or downstream Q/C.
                     WARNING: the correct operation of these thinning
                     procedures is not guaranteed if range checking is
                     disabled!!
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
   ROdata     struc  RO profile structure (thinned profiles)

 FILES
   'ThinFile' is a plain-text file which should be formatted as follows:
   Title=<title>
   Method=<method>
   Nlevels=<nlev>
   Hlevels=
   <level_1>
   <level_2>
   ...
   <level_nlev>

   where:
    <title>  is a free-text description up to 70 characters
    <method> specified the thinning method, and must be one of:
      SGLOG  : Savitzky-Golay smoothing filter with log interpolation
               to fixed number of thinned levels (see Reference)
      SGLIN  : Savitzky-Golay smoothing filter with linear interpolation
               to fixed number of thinned levels (see Reference)
      ASGLOG : Adaptive S-G smoothing filter with log interpolation
               to fixed number of thinned levels (see Reference)
      ASGLIN : Adaptive S-G smoothing filter with linear interpolation
               to fixed number of thinned levels (see Reference)
      LOG    : Logarithmic interpolation to fixed levels (no smoothing)
      LIN    : Linear      interpolation to fixed levels (no smoothing)
      SAMPLE : Simple sub-sampling (select or reject 1-in-N) to no more
               than the array size of the thinned levels.
      NONE   : no thinning (default if file cannot be read or its name
               blank or "0")
    <nlev>     is the (maximum or fixed) number of levels for output.
               If zero, disables thinning.
    <levels_n> are the required set of fixed levels (for SGLOG, SGLIN,
               LOG & LIN methods) as impact heights (impact parameter
               minus radius of curvature). Values should be monotonically
               increasing. May be omitted for SAMPLE and NONE but the key
               'Hlevels=' must always be present.
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_ascend
   ropp_io_rangecheck
   ropp_io_thin_select
   geometric2geopotential
   message
   message_get_routine
   message_set_routine
\end{Verbatim}
\textbf{USES:}\hspace{0.08in}\begin{Verbatim}
   typesizes
   ropp_io
   ropp_io_types
   geodesy
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   This subroutine thins a complete RO structure profiles - ie Level 1b
   L1+L2+C+O BA vs IP, Level 2a N vs ht, Level 2b T,q,H vs geopot ht
   (NB it does not thin Level 1a (SNR/Phase vs time) profiles.)
   The routine first reads & parses a thinning control file to determine
   the required thinning method (several are supported)
   and the number (maximum or fixed, depending on the method) and
   if appropriate the values for the fixed levels (as impact heights).
   The same thinning details are applied to all types of profiles.
   If the file cannot be read sucessfully, no thinning will be performed.
   If a logaritmic interpolation method is selected (SGLOG, ASGLOG, LOG),
   note that this is only applied to profile parameters that behave
   logarithmically with height (viz. bending angle, refractivity, pressure and
   humidity); all other parameters are interploated in linear mode
   (as if SGLIN, ASGLIN or LIN had been specified).

 REFERENCE
   Monodimensional data thinning for GPS radio occultations.
   SAF/GRAS/METO/ALG/ROPP/001
\end{Verbatim}
\section{Thin/ropp\_io\_thin\_fixed}
\textsl{[ Subroutines ]}

\label{ch:robo108}
\label{ch:Thin_ropp_io_thin_fixed}
\index{unsorted!ropp\_io\_thin\_fixed}\index{Subroutines!ropp\_io\_thin\_fixed}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_thin_fixed - Thin data by interpolating onto fixed altitude
                        levels.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   call ropp_io_thin_fixed ( nLev,     FullLev, FullVal, &
                             nThinLev, ThinLev, ThinVal, &
                             Method,   sigma )
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   nLev      int   Number of original levels
   FullLev   dflt  Original level values of the data
   FullVal   dflt  Original data  values
   nThinLev  int   Number of thinned levels
   ThinLev   dflt  Thinned level values
   Method    chr   Required interpolation method. One of:
                     SGLOG  : Savitzky-Golay smoothing + log interp.
                     SGLIN  : Savitzky-Golay smoothing + lin interp.
                     ASGLOG : Adaptive S-G   smoothing + log interp.
                     ASGLIN : Adaptive S-G   smoothing + lin interp.
                     LOG    : logarithmic interpolation
                     LIN    : linear interpolation
                    Default: LIN
   sigma     log   .T. indicates error scaling. Applicable to ASGLIN
                    and ASGLOG only (optional, default: .F.)

 OUTPUTS
   ThinVal   dlft  Thinned data values on ThinLev levels
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_thin_sg
\end{Verbatim}
\textbf{CALLED BY:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_thin_select
\end{Verbatim}
\textbf{USES:}\hspace{0.08in}\begin{Verbatim}
   typesizes
   ropp_io
   ropp_utils
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   This subroutine thins input data arrays to fixed number of levels.
   The levels are assumed to be altitudes with data values on those
   levels, but the algorithm is generic.
   Several interpolation methods are supported, including:
    a) Savitzky-Golay pre-smoothing & logarithmic interplation
       with optional adaptive filter parameters
    b) Logarithmic interpolation (no pre-smoothing)
    c) Linear      interpolation (no pre-smoothing)
   (For LOG interpolations, if either of the pair of values being interpolated
   are negative, linear interpolation is performed for that fixed height 
   point.)
   The input data values are interpolated to the given fixed (thinned)
   levels in the returned thinned array.
   Notes:
   1) The pairs of input (full) levels/values arrays and output (thinned)
      levels/values arrays must be of the same order, rank and size.
   2) The Adaptive SG takes account of the relative height 'resolutions'
      (maximum level separations) of the original and thinned levels, and
      modifies the width of the filter accordingly and the fitting polynomial
      order is set to 2 (1 for standard SG). Thus, thining of hi-res data
      applies more smoothing than for low-res data while still minimising
      vertical correlations or loss of information.
   3) If the full (input) height range does not fill the range of thinned
      (fixed) heights, the out-of-range data values will be set missing.
   4) If any input data values are flagged with 'missing' values
      (e.g. -99999) these will be included in the smoothing and/or
      interpolation which may not preserve any special missing data value for
      the thinned data values (but ought to remain invalid for that
      parameter in practice).
   5) Because of the offsetting for LOG interpolation, data with
      large negative values (e.g. missing data) may reduce the accuracy
      of the interpolation at all levels.
\end{Verbatim}
\section{Thin/ropp\_io\_thin\_select}
\textsl{[ Subroutines ]}

\label{ch:robo109}
\label{ch:Thin_ropp_io_thin_select}
\index{unsorted!ropp\_io\_thin\_select}\index{Subroutines!ropp\_io\_thin\_select}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_thin_select - select & apply a thinning method
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   CALL ropp_io_thin_select ( nLev,     Lev,      Val,     &
                              nThinLev, ThinLev,  ThinVal, &
                              Method,   nSampLev, sigma )
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   nLev      int   no. of full levels
   nThinLev  int   (max) no. of thinned levels
   Lev       dflt  array of full levels
   Val       dflt  array of full values
   ThinLev   dflt  array of thinned levels
                   (with values set before input for SGLOG,
                    SGLIN, ASGLOG, ASGLIN, LOG or LIN only)
   ThinVal   dflt  array of thinned values
   Method    chr   Method string. One of: SGLOG, SGLIN,
                    ASGLOG, ASGLIN, LOG, LIN, SAMPLE, NONE
   sigma     log   .T. indicates error smoothing
                   (used for ASG* & SG* methods only)

 OUTPUTS
   nSampLev  int   actual no. of thinned levels
   ThinLev   dflt  array of thinned levels
                   (with values set on output for SAMPLE only)
   ThinVal   dflt  array of thinned values
   Lev       dflt  array of full levels; on exit first nSamplev elements
                   is a copy of ThinLev, remainder are set 'missing'
   Val       dflt  array of full values; on exit first nSamplev elements
                   is a copy of ThinLev, remainder are set 'missing'
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_thin_fixed
   ropp_io_thin_skip
   where
\end{Verbatim}
\textbf{CALLED BY:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_thin
\end{Verbatim}
\textbf{USES:}\hspace{0.08in}\begin{Verbatim}
   typesizes
   ropp_io
   ropp_utils
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   This subroutine selects a thinning method from the input Method
   string and calls the appropriate routine(s) to apply that
   method to the input full levels and required output (thinned)
   levels values to return the thinned values. The supported methods
   include:
     ASGLOG : Adaptive S-G smoothing filter with log interpolation
              to fixed number of thinned levels (see Reference)
     ASGLIN : Adaptive S-G smoothing filter with linear interpolation
              to fixed number of thinned levels (see Reference)
     SGLOG  : Savitzky-Golay smoothing filter with log interpolation
              to fixed number of thinned levels (see Reference)
     SGLIN  : Savitzky-Golay smoothing filter with linear interpolation
              to fixed number of thinned levels (see Reference)
     LOG    : Logarithmic interpolation to fixed levels (no smoothing)
     LIN    : Linear      interpolation to fixed levels (no smoothing)
     SAMPLE : Simple sub-sampling (select or reject 1-in-N) to no more
              than the array size of the thinned levels.
     NONE   : explicitly do nothing.

 REFERENCE
   Mono-dimensional data thinning for GPS radio ccultations.
   SAF/GRAS/METO/ALG/ROPP/001
\end{Verbatim}
\section{Thin/ropp\_io\_thin\_sg}
\textsl{[ Subroutines ]}

\label{ch:robo110}
\label{ch:Thin_ropp_io_thin_sg}
\index{unsorted!ropp\_io\_thin\_sg}\index{Subroutines!ropp\_io\_thin\_sg}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_thin_sg
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
   call ropp_io_thin_sg (nLev, Val[,npoints=npoints][,order=order])
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
   This routine calculates coefficients of a linear filter following
   the Savitzky-Golay procedure as described in Numerical Recipes
   (see Ref.) and applies the smoothing kernel to the given data array.
   Optional arguments can be used to control the smoothing.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
   nLev      int   Number of levels in Val
   Val       dflt  Original data values
   order     int   Order of fitted polynomial (optional, default: 1)
   npoints   int   Number of points left & right of centre
                    (optional, default: 1)
   order     int   Order of fitted polynomial. Must be <= npoints
                    (optional, default: 1)

 OUTPUTS
   Val       dflt  Smoothed data values
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\textbf{USES:}\hspace{0.08in}\begin{Verbatim}
   typesizes
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
   This is a re-implementation of the Numerical Recipes routine
   savgol to solve the least squares problem. In contrast to the 
   Numerical Recipes routine, the full matrix inversion is done, allowing 
   for the simultaneous calculation of the smoothing polynomial and all its 
   derivatives at once. The smoothing filter is then applied to the given 
   array of data points.
\end{Verbatim}
\textbf{REFERENCES:}\hspace{0.08in}\begin{Verbatim}
   W.H. Press, S.A. Teukolsjy, W.T. Vetterling and B.P. Flannery,
   Numerical Recipes in C - The Art of Scientific Computing.
   2nd Ed., Cambridge University Press, 1992.
\end{Verbatim}
\section{Thin/ropp\_io\_thin\_skip}
\textsl{[ Subroutines ]}

\label{ch:robo111}
\label{ch:Thin_ropp_io_thin_skip}
\index{unsorted!ropp\_io\_thin\_skip}\index{Subroutines!ropp\_io\_thin\_skip}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_thin_skip - skip profile levels to simply sub-sample data
\end{Verbatim}
\textbf{ARGUMENTS:}\hspace{0.08in}\begin{Verbatim}
   nLev     (in)   int  No. of levels in full profile
   nThinLev (in)   int  Max. no. of thinned levels required
   skip1    (out)  int  Skip factor to select levels
   skip2    (out)  int  Skip factor to reject levels
   nSamp    (out)  int  Actual no. of thinned samples

 SYNPOSIS
   call ropp_io_thin_skip ( ROdata%Lev1b%Npoints, nThinLev, &
                            skip1, skip2, nSamp, DEBUG )
   do i = 1, ROdata%Lev1b%Npoints, skip1 ! select every skip1-th sample
     if ( mod(in,skip2) == 0 ) cycle     ! reject every skip2-th sample
     ....
   enddo
\end{Verbatim}
\textbf{CALLED BY:}\hspace{0.08in}\begin{Verbatim}
   ropp_io_thin_select
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
  Given the actual number of levels in a profile, and the
  maximum desired number, this subroutine calculates skip
  factors allowing appropriate thinning by
    - selecting 1-in-N levels when levels > maxlevels * 2
    - rejecting 1-in-N levels when max levels < levels < maxlevels * 2
    - no thinning when levels < maxlevels
  The routine can cater for thinning in cases where the input is
  high resolution (raw sampling) or low resolution (pre-thinned) but
  still too many levels for BUFR (either in terms of message length
  or user-application array size limits - e.g. MetDB is limited to 375
  levels).
  Note that this approach effectively sub-samples the original profile
  and there is no fixed no. of thinned levels (just a maximum).
\end{Verbatim}
\section{Variable-lists/size}
\textsl{[ Functions ]}

\label{ch:robo112}
\label{ch:Variable_lists_size}
\index{unsorted!size}\index{Functions!size}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    size - Number of variables in a variable list.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    n = size(vlist)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This function returns the number of variables in a variable list, i.e.
    the size of the variable list.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    type(Vlisttype)    :: vlist       A variable list.

    or one of its sub-types:

    type(VlisttypeD0d) :: vlist_0d
    type(VlisttypeD1d) :: vlist_1d
    type(VlisttypeD2d) :: vlist_2d
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    int                :: int
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    If a vlist is empty (i.e. has no variables stored in it), size returns 0.

    In the present implementation, variable lists are limited to double
    precision scalar, one- or two-dimensional floating point numbers. Internally,
    these are implemented as linked lists, where seperate lists are kept for
    the various data types and array shapes. The individual vlists are combined
    into a single Vlisttype structure.

    This function is overloading the intrinsic size() function for the various
    (sub-) types of vlists.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\section{Variables/ncdf\_defvar}
\textsl{[ Subroutines ]}

\label{ch:robo113}
\label{ch:Variables_ncdf_defvar}
\index{unsorted!ncdf\_defvar}\index{Subroutines!ncdf\_defvar}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_defvar - Define a new variable in the current netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    varid = ncdf_defvar(name, long_name, units [, dimids])
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine closes the current netCDF data file. Error handling
    is done inside the routine.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    character(len = *)    :: name        Name of the newly created variable.
    character(len = *)    :: long_name   Long name of the newly created variable.
    character(len = *)    :: units       Units of the newly created variable.
    integer, dimension(:) :: dimids      netCDF dimension ID's for the newly
                                           created variable (see NOTES below).
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    integer               :: varid       netCDF id of newly created variable.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    If dimids are not given, a scalar variable is created. An array variable
    can be defined by specifying the ID's of the dimensions the variable
    adheres to as elements in the dimids array.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_defdim
    ncdf_putvar
\end{Verbatim}
\section{Variables/ncdf\_getvar}
\textsl{[ Subroutines ]}

\label{ch:robo114}
\label{ch:Variables_ncdf_getvar}
\index{unsorted!ncdf\_getvar}\index{Subroutines!ncdf\_getvar}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getvar - Read a variable from a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_getvar(varname, data)
      - or -
    call ncdf_getvar(varname, data [, start = (/.../)[, count = (/.../)]])
      - or -
    call ncdf_getvar(varname, data [, rec = ...])
      - or -
    call ncdf_getvar(varname, data [, ncfile = ...], ...)
      - or -
    call ncdf_getvar(varname, data [, ncid = ...], ...)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine reads data from a variable of a netCDF data file.

    If neither start and/or count nor rec are given, the data is simply
    read from the specified netCDF variable. If start and count are given,
    those define into which hyperslab of the netCDF variable the data is
    read; see the netCDF documentation for details. If only start values
    are given, the remaining part of the respective dimensions of the variable
    in the netCDF file will be read into data. If only count values are
    given, data is read starting at the first element of each dimension
    of the variable in the netCDF data file.

    The optional keyword rec is provided as a faster alternative to the
    start / count keywords for netCDF data files with an unlimited record
    dimension, and is only applicable in this case (and only if the netCDF
    variable to be read into is defined using this dimension); see examples
    below.

    By default, data is read from the current netCDF data file. If either
    ncid (the numeric id of a previously opened netCDF data file) or ncfile
    (the full path name to an already existing netCDF data file) are given,
    the corresponding file will be used for input instead, and subsequently
    becomes the 'current' netCDF data file for all tasks performed by the 
    ncdf library.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    character(len = *)    :: varname   Name of netCDF variable to write.

    The following arguments are all optional:
    integer               :: rec       Number or record for an unlimited
                                         dimension (if it exists).
    integer, dimension(:) :: start     start values.
    integer, dimension(:) :: count     count values.
    character(len = *)    :: ncfile    Name of netCDF data file to write to.
    integer               :: ncid      netCDF id of file to write to.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    any type              :: data      Data to be written (scalar or array).
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The use of the optional arguments / keywords rec and start/count are
    mutually exclusive, as are the keywords ncid and ncfile.
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    To read an n-dimensional 'data' array from a netCDF variable named
    'field' within the current netCDF data file, where the Fortran variable
    has been declared to be consistent with the definition of the netCDF
    variable, use

       call ncdf_getvar('field', data)

    Assume that a netCDF variable 'bulk' describes a 3 dimensional data
    field along dimensions x, y, and z. Reading a two dimensional hyperslab
    'data' containing all values along the x and z coordinates, but for only
    one index 'i' in y, use

       call ncdf_getvar('bulk', data, start = (/1,   i, 1/), $
                                      count = (/n_x, 1, n_z/))

    where n_x and n_z denote the number of data points along the x and z
    dimensions, respectively.

    Assume that the netCDF variable 'field' contains a horizontal field
    depending on longitude, latitude and time; time varies along the
    unlimited netCDF dimension. Reading a two-dimensional hyperslap of
    the data set valid at time index 'i', this

       call ncdf_getvar('field', array, rec = i)

    is a slightly easier way to read that hyperslab compared to the
    (otherwise equivalent) alternative

       call ncdf_getvar('field', array, start = (/1,     1, i/), $
                                        count = (/n_x, n_y, 1))
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getvar_alloc
    ncdf_putvar
\end{Verbatim}
\section{Variables/ncdf\_getvar\_alloc}
\textsl{[ Functions ]}

\label{ch:robo115}
\label{ch:Variables_ncdf_getvar_alloc}
\index{unsorted!ncdf\_getvar\_alloc}\index{Functions!ncdf\_getvar\_alloc}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getvar_alloc - Read a variable from a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_getvar(varname, scalar, rec = ..., start = ...)             ! scalar
      - or -
    call ncdf_getvar(varname, array, rec = ..., start = ..., count = ...) ! array
      - or -
    call ncdf_getvar(ncfile, varname, scalar|array, ...)
      - or -
    call ncdf_getvar(ncid, varname, scalar|array, ...)
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    character(len = *)     :: ncfile    Name of netCDF data file to read from.
    integer                :: ncid      netCDF id of file to read from.

    character(len = *)     :: varname   Name of variable to read.

    integer, dimension(:)  :: start     array of start values (see netCDf documentation).
    integer, dimension(:)  :: count     array of count values (see netCDF documentation).

    Note that all keyword variables are optional.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    real(dp)               :: scalar
    real(dp), dimension(:) :: array
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine reads a variable from the current netCDF data
    file.
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    Assume that you want to read variables alpha_b and impact from a netCDF
    data file 'test.nc', try

       use ncdf
         ...
       integer, parameter   :: n_levels = <some_number>
         ...
       real(dp)             :: alpha(n_levels), impact(n_levels)
         ...
       call ncdf_open('test.nc')
       call ncdf_getvar('alpha_b', alpha)
       call ncdf_getvar('impact',  impact)
       call ncdf_close()
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_getvar
    ncdf_putvar
\end{Verbatim}
\section{Variables/ncdf\_isvar}
\textsl{[ Functions ]}

\label{ch:robo116}
\label{ch:Variables_ncdf_isvar}
\index{unsorted!ncdf\_isvar}\index{Functions!ncdf\_isvar}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_isvar - Check if a given variable is in the current netCDF
                 data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    true_or_false = ncdf_isvar(name)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This function tries to inquire if a given named variable does exist
    within the current netCDF data file, and returns .true. if it does,
    or .false. otherwise.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    name (str)     -  variable name to be checked.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    true_or_false  -  logical value, .true. if varname exist in the current 
                         netCDF data file.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The netCDF data file must have been opened before.
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    To check if a variable is contained in the current netCDF, and handle
    the situation accordingly:

       if (ncdf_isvar(name)) then
          call do_this()
       else
          call do_that()
       endif
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_create
    ncdf_open
    ncdf_close
\end{Verbatim}
\section{Variables/ncdf\_putvar}
\textsl{[ Subroutines ]}

\label{ch:robo117}
\label{ch:Variables_ncdf_putvar}
\index{unsorted!ncdf\_putvar}\index{Subroutines!ncdf\_putvar}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_putvar - Write a variable to a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_putvar(varname, data)
      - or -
    call ncdf_putvar(varname, data [, start = (/.../)[, count = (/.../)]])
      - or -
    call ncdf_putvar(varname, data [, rec = ...])
      - or -
    call ncdf_putvar(varname, data [, ncfile = ...], ...)
      - or -
    call ncdf_putvar(varname, data [, ncid = ...], ...)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine writes data into a variable of a netCDF data file. The
    variable must have been defined previously.

    If neither start and/or count nor rec are given, the data is simply
    written to the specified netCDF variable. If start and count are given,
    those define into which hyperslab of the netCDF variable the data is
    written; see the netCDF documentation for details. If only start values
    are given, the remaining part of the respective dimensions of the variable
    in the netCDF file will be filled with data. If only count values are
    given, data is written starting at the first element of each dimension
    of the variable in the netCDF data file.

    The optional keyword rec is provided as a faster alternative to the
    start / count keywords for netCDF data files with an unlimited record
    dimension, and is only applicable in this case (and only if the netCDF
    variable to be written into is defined using this dimension); see examples
    below. 

    By default, data is written into the current netCDF data file. If either
    ncid (the numeric id of a previously opened netCDF data file) or ncfile
    (the full path name to an already existing netCDF data file) are given,
    the corresponsing file will be used for output instead, and subsequently
    becomes the 'current' netCDF data file for all tasks performed by the
    ncdf library.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    character(len = *)    :: varname   Name of netCDF variable to write.
    any type              :: data      Data to be written (scalar or array).

    The following arguments are all optional:
    integer               :: rec       Number or record for an unlimited
                                         dimension (if it exists).
    integer, dimension(:) :: start     start values.
    integer, dimension(:) :: count     count values.
    character(len = *)    :: ncfile    Name of netCDF data file to write to.
    integer               :: ncid      netCDF id of file to write to.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    None; however, data is written to the current (or otherwise specified)
    netCDF data file.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The use of the optional arguments / keywords rec and start/count are
    mutually exclusive, as are the keywords ncid and ncfile.
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    To write an n-dimensional 'data' array into a netCDF variable named
    'field' within the current netCDF data file, where the netCDF variable
    has been defined to be consistent with the declaration of 'data', use

       call ncdf_putvar('field', data)

    Assume that a netCDF variable 'bulk' describes a 3 dimensional data
    field along dimensions x, y, and z. Writing a two dimensional hyperslab
    'data' filling all values along the x and z coordinates, but for only
    one index 'i' in y, use

       call ncdf_putvar('bulk', data, start = (/1,   i, 1/), $
                                      count = (/n_x, 1, n_z/))

    where n_x and n_z denote the number of data points along the x and z
    dimensions, respectively.

    Assume that the netCDF variable 'field' is to hold a horizontal field
    depending on longitude, latitude and time; time is intended to vary
    along an unlimited netCDF dimension. If the variable 'array' holds a
    two-dimensional hyperslap of the data set valid at time index 'i',
    this

       call ncdf_putvar('field', array, rec = i)

    is a slightly easier way to write that hyperslab compared to the
    (otherwise equivalent) alternative

       call ncdf_putvar('field', array, start = (/1,     1, i/), $
                                        count = (/n_x, n_y, 1))
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ncdf_defvar
    ncdf_getvar
    ncdf_getvar_alloc
\end{Verbatim}
\section{Variables/ncdf\_renvar}
\textsl{[ Subroutines ]}

\label{ch:robo118}
\label{ch:Variables_ncdf_renvar}
\index{unsorted!ncdf\_renvar}\index{Subroutines!ncdf\_renvar}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_renvar - Rename a variable in a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    call ncdf_renvar(old_name, new_name [, file] [, ncid])
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This routine renames an exiting variable in the current netCDF data file
    (or the netCDF file specified by either file or ncid).
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    old_name  -  old variable name.
    new_name  -  new variable name
    file      -  file name of the netCDF data file.
    ncid      -  netCDF id of the netCDF data file.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The optional file and ncid arguments are mutually exclusive.
\end{Verbatim}
\section{Variables/ncdf\_save}
\textsl{[ Subroutines ]}

\label{ch:robo119}
\label{ch:Variables_ncdf_save}
\index{unsorted!ncdf\_save}\index{Subroutines!ncdf\_save}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ncdf_save - Save a variable to a netCDF data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    use ncdf
      ...
    call ncdf_save(name, values, long_name, units, dimension)
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    character(len = *)           :: name       Name of the variable to be created.
    (any numeric type)           :: values     Data to be written.
    character(len = *), optional :: long_name  'long_name' attribute.
    character(len = *), optional :: units      'units' attribute.
    logical,            optional :: dimension  If .true., the variable is defines
                                                 a coordinate dimension .

    All optional paramaters should be accessed via keywords.
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine defines and writes a variable to the current netCDF data
    file. Error handling is done inside the routine.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    The routine is intended to be used for the occasional storage of data
    in netCDF data files, e.g. for diagnostic or debugging purposes, but
    not for saving large amounts of data regularly. For the latter, it is
    more efficient to first define and then write all variables to the
    netCDF data file via the ncdf_defdim, ncdf_defvar and ncdf_varput
    routines.
\end{Verbatim}
\textbf{EXAMPLE:}\hspace{0.08in}\begin{Verbatim}
    Assume that you want to write two ariables x and y to a newly created
    netCDF data file 'test.nc'. Try

       use ncdf
         ...
       integer, parameter :: n_levels = <some_number>
         ...
       real               :: x(n_levels), y(n_levels)
         ...
       call ncdf_create('test.nc')
       call ncdf_save('x', x, long_name = 'My coordinates', units = 'm', &
                              dimension = .true.)
       call ncdf_save('y', y, long_name = 'My function values', units = 'K')
       call ncdf_close()

    To add the same variables to an already existing netCDF data file 
    'test2.nc', simply replace the ncdf_create() call by an ncdf_open() call:

       call ncdf_open('test.nc')
       call ncdf_save('x', x, long_name = 'My coordinates', units = 'm', &
                              dimension = .true.)
       call ncdf_save('y', y, long_name = 'My function values', units = 'K')
       call ncdf_close()
\end{Verbatim}
\section{Writing/ropp\_io\_write}
\textsl{[ Subroutines ]}

\label{ch:robo120}
\label{ch:Writing_ropp_io_write}
\index{unsorted!ropp\_io\_write}\index{Subroutines!ropp\_io\_write}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_write - Write an ROPP data file.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    call ropp_io_write(data [, file=...] [, path=...], [,output_precision=...],
                            [, append=...] [, rec=...] [, ranchk=...]
                            [, ierr=...])
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine writes RO event data to a specified file. The file
    written conforms to the ROPP v1.1 data format and is netCDF based.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    data  dtyp   one of the output data types defined in ropp_io_types:
                    ROprof
                    <TBD>
    file    chr    name of output file (optional; default is autogenerated)
    path    chr    name of path for output directory (optional; default is PWD)
    output_precision   'che float' or 'double' (optional; default is float)
    multi   log    multiple-profile flag (optional). Valid values are:
                    - .T. create single file with multiple profiles
                    - .F. create different files for multiple profiles
    append  log    file append flag (optional). Valid values are:
                    - .T. append to existing file
                    - .F. start a new file (overwrite any existing file) (default)
    rec     int    specific record to write for multifiles (optional)
                   (default: next record in sequence)
    ranchk  log    range check flag (optional) Valid values are:
                    - .T. to perform a range check prior to output (default) or
                    - .F. to skip range checking
                   This flag should not normally be used or if present, be
                   set to default .T.. It is intended for use only when
                   deliberately invalid data is explicitly required to
                   survive into the output netCDF file, such as when
                   generating invalid data for testing of downstream Q/C.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    ierr  int    exit I/O code;
                    -  0 = ok
                    - -1 = unexpected EOF
                    - I/O error (system dependent or as obtained from netCDF)
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    If file is not given, a file name will be autogenerated based on the
    content of the of the data structure (using the occ_id element of the
    data structure).

    If ierr is not given, the routine will abort in case of an error.
\end{Verbatim}
\textbf{SEE ALSO:}\hspace{0.08in}\begin{Verbatim}
    ropp_io
    ropp_io_types
    ropp_io_read
    ropp_io_occid
\end{Verbatim}
\textbf{CALLS:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_write_ncdf
\end{Verbatim}
\section{Writing/ropp\_io\_write\_ncdf\_def}
\textsl{[ Subroutines ]}

\label{ch:robo121}
\label{ch:Writing_ropp_io_write_ncdf_def}
\index{unsorted!ropp\_io\_write\_ncdf\_def}\index{Subroutines!ropp\_io\_write\_ncdf\_def}
\textbf{NAME:}\hspace{0.08in}\begin{Verbatim}
    ropp_io_write_ncdf_def - Define variables in a netCDF for the given data.
\end{Verbatim}
\textbf{SYNOPSIS:}\hspace{0.08in}\begin{Verbatim}
    call ropp_io_write_ncdf_def(data, output_precision)
\end{Verbatim}
\textbf{DESCRIPTION:}\hspace{0.08in}\begin{Verbatim}
    This subroutine defines variables in an already created netCDF data file.
    It defines variables (names, descriptions, units, ranges...) corresponding
    to the actual data parameters.
\end{Verbatim}
\textbf{INPUTS:}\hspace{0.08in}\begin{Verbatim}
    type(ROprof)          :: data               Data structure to be written.
    char(len=*), optional :: output_precision   'float' or 'double'.
\end{Verbatim}
\textbf{OUTPUT:}\hspace{0.08in}\begin{Verbatim}
    None.
\end{Verbatim}
\textbf{NOTES:}\hspace{0.08in}\begin{Verbatim}
    For most variables, units as defined in the default declarations for the RO
    structure) are used as 'units' variable attribute. This ensures that
    newly created ROPP data files contains data in standard units as defined
    by the ROPP User Documentation. The drawback is that users *must* ensure
    that their unit settings in the 'data' structure are correct if they use
    different units in their own internal processing.

    For all variables, valid ranges as specified in the user-provided data
    structure are used for the definition of the valid_range attribute of all
    netCDF variables. This gives the user full control over the acceptable
    data values. This requires that the valid range values are given in the
    the same units as the data. Range values are converted to ROPP standard
    units as necessary before being written to the netCDF file.

    A netCDF file must have been created or opened (in an append mode) before
    using the ncdf_create() or ncdf_open(). This subroutine only works on the
    current (as seen by the ncdf library) netcdf file.
\end{Verbatim}
