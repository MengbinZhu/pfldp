! $Id: message_bs_escape.f90 2282 2009-10-22 09:49:29Z frhl $

!****si* Messages/message_bs_escape *
!
! NAME
!    message - Issue an information / warning / error message.
!            --> BASED ON MARQUARDT COLLECTION LIBRARY ROUTINE
!
! SYNOPSIS
!   use ropp_utils
!     ...
!   call message(type, text [, status])
!     ...
!
! DESCRIPTION
!    This subroutine prints an error message. For fatal errors, the program
!    is aborted, and an exit status is set. The output will look like this:
!
!       MESSAGE_TYPE (<prog>/<routine>/<add>):
!          Text of the message, which might have multiple lines of text.
!
!    where the MESSAGE_TYPE is determined by the value of the type argument.
!    Fatal error messages result in termination of the program.
!
! INPUTS
!   int   type    The type of the message which can be msg_cont, msg_info,
!                   msg_warn, msg_error or msg_fatal (as defined in the
!                   module messages). The following values are supported:
!
!                     msg_cont    This will continue the previous message
!                                   (and provides a way to build up multi
!                                   line informational or warning messages).
!                     msg_info    Informational message; message starts with
!                                   'INFO:'
!                     msg_warn    Warning message; message starts with
!                                   'WARNING:'
!                     msg_error   Error message; message starts with
!                                   'ERROR:'
!                     msg_fatal   Fatal error message; message starts with
!                                   'FATAL ERROR:'
!
!                   For fatal errors, the program will terminate with an
!                   an error code as given in status if the Fortran compiler
!                   supports a 'call exit(status)'.
!
!   char* text    Error (or informational) message to be printed. This is
!                   a text string which may have embedded C-style control
!                   characters. Currently supported are the following ones:
!
!                     \n   newline; use for multi-line messages
!                     \t   tabulator
!                     \'   single and...
!                     \"   ...double hyphens
!                     \a   terminal bell (i.e., a 'beep')
!                     \b   backspace
!                     \\   backslash
!
!   int   status  Unix error status in case of a fatal error. This argument is
!                   optional.
!
! OUTPUT
!   Text is printed to stdout or stderr.
!
! NOTES
!   The MESSAGE_TYPE qualifiers in the first line of the message are determined
!   by the value of the type parameter; use one of the parameters provided in
!   the module messages (as described above). The additional qualifiers after
!   the main one can be set via the additional routines message_set_program(),
!   message_set_routine() and message_set_addinfo(). If those qualifiers are
!   set to ' ', they will not be printed. Similar *_set_* routines exist to
!   enquire about the current setting of the additional qualifiers.
!
!   Multiline texts can be generated by adding '\n' for line breaks with a
!   single call to message. Note, however, that the routine prints three blanks
!   in front of the error string; for multiline error messages, these must be
!   added manually after the '\n'. An alternative way to create non-fatal 
!   multiline messages is to use the routine repeatedly with the 'msg_cont'
!   type parameter to write out individual lines.
!
!   The default exit status (if status is not specified) in case of fatal errors
!   is -1.
!
! SEE ALSO
!   assert
!   message_set_program
!   message_get_program
!   message_set_routine
!   message_get_routine
!   message_set_addinfo
!   message_get_addinfo
!
! AUTHOR
!    C. Marquardt, Darmstadt, Germany              <christian@marquardt.sc>
!
! COPYRIGHT
!
!    Copyright (c) 2005 Christian Marquardt        <christian@marquardt.sc>
!
!    All rights reserved.
!
!    Permission is hereby granted, free of charge, to any person obtaining
!    a copy of this software and associated documentation files (the
!    "Software"), to deal in the Software without restriction, including
!    without limitation the rights to use, copy, modify, merge, publish,
!    distribute, sublicense, and/or sell copies of the Software, and to
!    permit persons to whom the Software is furnished to do so, subject to
!    the following conditions:
!
!    The above copyright notice and this permission notice shall be
!    included in all copies or substantial portions of the Software as well
!    as in supporting documentation.
!
!    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
!    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
!    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
!    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
!    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
!    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
!    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
!
!****

!-------------------------------------------------------------------------------
! 1. Simple version
!-------------------------------------------------------------------------------

subroutine message(type, string, status)

! Declarations
! ------------

  use messages, not_this => message

  implicit none

  integer,            intent(in) :: type
  character(len = *), intent(in) :: string
  integer,            optional   :: status

  integer                        :: stat
  character(len = 1024)          :: post, xstring
  character(len = 1024)          :: ropp_msg_mode

! Read ROPP_MSG_MODE environment variable to set msg_MODE level

  IF (.NOT. msg_MODE_READ) THEN
    CALL GETENV( "ROPP_MSG_MODE", ropp_msg_mode)
    SELECT CASE (TRIM(ropp_msg_mode))
    CASE ("QuietMode")
      msg_MODE = QuietMode
    CASE ("NormalMode")
      msg_MODE = NormalMode
    CASE ("VerboseMode")
      msg_MODE = VerboseMode
    END SELECT
    msg_MODE_READ = .true.
  ENDIF

! Exit status
! -----------

  if (present(status)) then
     stat = status
  else
     stat = -1
  endif

! Set names of program and routine
! --------------------------------

  if (len_trim(msg_program) == 0) then
     if (len_trim(msg_routine) == 0) then
        if (len_trim(msg_addinfo) == 0) then
           post = ':'
        else
           post = ' (' // trim(msg_addinfo) // '):'
        endif
     else
        if (len_trim(msg_addinfo) == 0) then
           post = ' (from ' // trim(msg_routine) // '):'
        else
           post = ' (from ' // trim(msg_routine) // '/' // &
                               trim(msg_addinfo) // '):'
        endif
     endif
  else
     if (len_trim(msg_routine) == 0) then
        if (len_trim(msg_addinfo) == 0) then
           post = ' (from ' // trim(msg_program) // '):'
        else
           post = ' (from ' // trim(msg_program) // '/' // &
                               trim(msg_addinfo) // '):'
        endif
     else
        if (len_trim(msg_addinfo) == 0) then
           post = ' (from ' // trim(msg_program) // '/' // &
                               trim(msg_routine) // '):'
        else
           post = ' (from ' // trim(msg_program) // '/' // &
                               trim(msg_routine) // '/' // &
                               trim(msg_addinfo) // '):'
        endif
     endif
  endif

! Handle control characters in string
! -----------------------------------

  xstring = string

! Print error message
! -------------------

  select case(type)
  case(msg_cont)
    IF (msg_MODE >= NormalMode)   &
     write(stdout, *)  '   ' // trim(xstring) 
  case(msg_diag)
    IF (msg_MODE == VerboseMode)   &
     write(stdout, *) '...' // trim(post) // '  ' // trim(xstring)
  case(msg_info)
    write(stdout, *) 'INFO' // trim(post) // '  ' // trim(xstring)
  case(msg_warn)
    IF (msg_MODE >= NormalMode) THEN
      write(stdout, *) ' '
      write(stdout, *) 'WARNING' // trim(post) // '  ' // trim(xstring)
    ENDIF
  case(msg_error)
    IF (msg_MODE >= QuietMode) THEN
      write(stderr, *) ' '
      write(stderr, *) 'ERROR' // trim(post) // '  ' // trim(xstring)
    ENDIF
  case(msg_fatal)
    IF (msg_MODE >= QuietMode) THEN
      write(stderr, *) ' '
      write(stderr, *) 'FATAL ERROR' // trim(post) // '  ' // trim(xstring)
      write(stderr, *) ' '
    ENDIF
    call exit(stat)
  case(msg_noin)
     write(stdout, *) trim(xstring)
  end select

end subroutine message
