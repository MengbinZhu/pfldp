! $Id: message.f90 2905 2011-06-22 11:25:15Z idculv $

!****s* Messages/message *
!
! NAME
!    message - Issue an information / warning / error message.
!            --> BASED ON MARQUARDT COLLECTION LIBRARY ROUTINE
!
! SYNOPSIS
!   use ropp_utils
!     ...
!   call message(type, text [, status])
!     ...
!
! DESCRIPTION
!    This subroutine prints an error message. For fatal errors, the program
!    is aborted, and an exit status is set. The output will look like this:
!
!       MESSAGE_TYPE (<prog>/<routine>/<add>):
!          Text of the message, which might have multiple lines of text.
!
!    where the MESSAGE_TYPE is determined by the value of the type argument.
!    Fatal error messages result in termination of the program.
!
! INPUTS
!   int   type    The type of the message which can be msg_cont, msg_info,
!                   msg_warn, msg_error or msg_fatal (as defined in the
!                   module messages). The following values are supported:
!
!                     msg_cont    This will continue the previous message
!                                   (and provides a way to build up multi
!                                   line informational or warning messages).
!                     msg_info    Informational message; message starts with
!                                   'INFO:'
!                     msg_warn    Warning message; message starts with
!                                   'WARNING:'
!                     msg_error   Error message; message starts with
!                                   'ERROR:'
!                     msg_fatal   Fatal error message; message starts with
!                                   'FATAL ERROR:'
!
!                   For fatal errors, the program will terminate with an
!                   an error code as given in status if the Fortran compiler
!                   supports a 'call exit(status)'.
!
!   char* text    Error (or informational) message to be printed. This is
!                   a text string which may have embedded C-style control
!                   characters. Currently supported are the following ones:
!
!                     \n   newline; use for multi-line messages
!                     \t   tabulator
!                     \'   single and...
!                     \"   ...double hyphens
!                     \a   terminal bell (i.e., a 'beep')
!                     \b   backspace
!                     \\   backslash
!
!   int   status  Unix error status in case of a fatal error. This argument is
!                   optional.
!
! OUTPUT
!   Text is printed to stdout or stderr.
!
! NOTES
!   The MESSAGE_TYPE qualifiers in the first line of the message are determined
!   by the value of the type parameter; use one of the parameters provided in
!   the module messages (as described above). The additional qualifiers after
!   the main one can be set via the additional routines message_set_program(),
!   message_set_routine() and message_set_addinfo(). If those qualifiers are
!   set to ' ', they will not be printed. Similar *_set_* routines exist to
!   enquire about the current setting of the additional qualifiers.
!
!   Multiline texts can be generated by adding '\n' for line breaks with a
!   single call to message. Note, however, that the routine prints three blanks
!   in front of the error string; for multiline error messages, these must be
!   added manually after the '\n'. An alternative way to create non-fatal 
!   multiline messages is to use the routine repeatedly with the 'msg_cont'
!   type parameter to write out individual lines.
!
!   The default exit status (if status is not specified) in case of fatal errors
!   is -1.
!
! SEE ALSO
!   message_set_program
!   message_get_program
!   message_set_routine
!   message_get_routine
!   message_set_addinfo
!   message_get_addinfo
!
! AUTHOR
!    C. Marquardt, Darmstadt, Germany              <christian@marquardt.sc>
!
! COPYRIGHT
!
!    Copyright (c) 2005 Christian Marquardt        <christian@marquardt.sc>
!
!    All rights reserved.
!
!    Permission is hereby granted, free of charge, to any person obtaining
!    a copy of this software and associated documentation files (the
!    "Software"), to deal in the Software without restriction, including
!    without limitation the rights to use, copy, modify, merge, publish,
!    distribute, sublicense, and/or sell copies of the Software, and to
!    permit persons to whom the Software is furnished to do so, subject to
!    the following conditions:
!
!    The above copyright notice and this permission notice shall be
!    included in all copies or substantial portions of the Software as well
!    as in supporting documentation.
!
!    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
!    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
!    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
!    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
!    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
!    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
!    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
!
!****

!--------------------------------------------------------------------------
! 1. Simple version
!--------------------------------------------------------------------------

subroutine message(type, string, status)

! Declarations
! ------------

  use messages, not_this => message

  implicit none

  interface
     function get_io_unit() result(unit)
       implicit none
       integer :: unit
     end function get_io_unit
  end interface


  integer,            intent(in) :: type
  character(len = *), intent(in) :: string
  integer,            optional   :: status

  integer                        :: stat
  integer                        :: idx
  character(len = 2024)          :: post, xstring
  character(len = 1024)          :: ropp_msg_mode

  integer                        :: logFileLrn
  character(len = *), parameter  :: logStrPrepend = ' ROPP '


! Read ROPP_MSG_MODE environment variable to set msg_MODE level

  IF (.NOT. msg_MODE_READ) THEN
    CALL GETENV( "ROPP_MSG_MODE", ropp_msg_mode)
    SELECT CASE (TRIM(ropp_msg_mode))
    CASE ("QuietMode")
      msg_MODE = QuietMode
    CASE ("NormalMode")
      msg_MODE = NormalMode
    CASE ("VerboseMode")
      msg_MODE = VerboseMode
    END SELECT
    msg_MODE_READ = .true.
  ENDIF

! Exit status
! -----------

  if (present(status)) then
     stat = status
  else
     stat = -1
  endif

! Set names of program and routine
! --------------------------------

  if (len_trim(msg_program) == 0) then
     if (len_trim(msg_routine) == 0) then
        if (len_trim(msg_addinfo) == 0) then
           post = ':'
        else
           post = ' (' // trim(msg_addinfo) // '):'
        endif
     else
        if (len_trim(msg_addinfo) == 0) then
           post = ' (from ' // trim(msg_routine) // '):'
        else
           post = ' (from ' // trim(msg_routine) // '/' // &
                               trim(msg_addinfo) // '):'
        endif
     endif
  else
     if (len_trim(msg_routine) == 0) then
        if (len_trim(msg_addinfo) == 0) then
           post = ' (from ' // trim(msg_program) // '):'
        else
           post = ' (from ' // trim(msg_program) // '/' // &
                               trim(msg_addinfo) // '):'
        endif
     else
        if (len_trim(msg_addinfo) == 0) then
           post = ' (from ' // trim(msg_program) // '/' // &
                               trim(msg_routine) // '):'
        else
           post = ' (from ' // trim(msg_program) // '/' // &
                               trim(msg_routine) // '/' // &
                               trim(msg_addinfo) // '):'
        endif
     endif
  endif


  if (msg_logFile(1:1) /= ' ') then

     ! -----------------------------------
     ! Ignore control characters in string
     ! -----------------------------------

     xstring = string

     do
        idx = INDEX(trim(xstring),'\a')
        if(idx == 0) exit
        xstring(idx:idx+1) = achar(32)
     enddo
     do
        idx = INDEX(trim(xstring),'\b')
        if(idx == 0) exit
        xstring(idx:idx+1) = achar(32)
     enddo
     do
        idx = INDEX(trim(xstring),'\t')
        if(idx == 0) exit
        xstring(idx:idx+1) = achar(32)
     enddo
     do
        idx = INDEX(trim(xstring),'\n')
        if(idx == 0) exit
        xstring(idx:idx+1) = achar(32)
     enddo
     do
        idx = INDEX(trim(xstring), "\'")
        if(idx == 0) exit
        xstring(idx:idx+1) = achar(32)
     enddo
     do
        idx = INDEX(trim(xstring),'\"')
        if(idx == 0) exit
        xstring(idx:idx+1) = achar(32)
     enddo
     do
        idx = INDEX(trim(xstring),'\\')
        if(idx == 0) exit
        xstring(idx:idx+1) = achar(32)
     enddo

     ! -----------------
     ! Log error message
     ! -----------------

     logFileLrn = get_io_unit()
     open(logFileLrn, file=msg_logFile, status='unknown', position='append')

     select case(type)
     case(msg_cont)
       IF (msg_MODE >= NormalMode)   &
          write(logFileLrn, '(a)') logStrPrepend // '   ' // trim(xstring)
     case(msg_diag)
       IF (msg_MODE == VerboseMode)   &
          write(logFileLrn, '(a)') logStrPrepend // '...' // trim(post) // '  ' // trim(xstring)
     case(msg_info)
          write(logFileLrn, '(a)') logStrPrepend // 'INFO' // trim(post) // '  ' // trim(xstring)
     case(msg_warn)
       IF (msg_MODE >= NormalMode) THEN
         write(logFileLrn, '(a)') logStrPrepend // 'WARNING' // trim(post) // '  ' // trim(xstring)
       ENDIF
     case(msg_error)
       IF (msg_MODE >= QuietMode) THEN
          write(logFileLrn, '(a)') logStrPrepend // 'ERROR' // trim(post) // '  ' // trim(xstring)
        ENDIF
      case(msg_fatal)
       IF (msg_MODE >= QuietMode) THEN
         write(logFileLrn, '(a)') logStrPrepend // 'FATAL ERROR' // trim(post) // '  ' // trim(xstring)
       ENDIF
       close(logFileLrn)
       call exit(stat)
     case(msg_noin)
       IF (msg_MODE >= NormalMode)   &
          write(logFileLrn, '(a)') logStrPrepend // trim(xstring)
     end select

     close(logFileLrn)
     return

  else

     ! -----------------------------------
     ! Handle control characters in string
     ! -----------------------------------

     xstring = string                       

     do
        idx = INDEX(trim(xstring),'\a')
        if(idx == 0) exit
        xstring(idx:idx+1) = achar(07)
     enddo
     do
        idx = INDEX(trim(xstring),'\b')
        if(idx == 0) exit
        xstring(idx:idx+1) = achar(08)
     enddo
     do
        idx = INDEX(trim(xstring),'\t')
        if(idx == 0) exit
        xstring(idx:idx+1) = achar(09)
     enddo
     do
        idx = INDEX(trim(xstring),'\n')
        if(idx == 0) exit
        xstring(idx:idx+1) = achar(10)
     enddo
     do
        idx = INDEX(trim(xstring), "\'")
        if(idx == 0) exit
        xstring(idx:idx+1) = achar(39)
     enddo
     do
        idx = INDEX(trim(xstring),'\"')
        if(idx == 0) exit
        xstring(idx:idx+1) = achar(34)
     enddo
     do
        idx = INDEX(trim(xstring),'\\')
        if(idx == 0) exit
        xstring(idx:idx+1) = achar(92)
     enddo

     ! -------------------
     ! Print error message
     ! -------------------

     select case(type)
     case(msg_cont)
       IF (msg_MODE >= NormalMode)   &
          write(stdout, '(a)')  '   ' // trim(xstring)
     case(msg_diag)
       IF (msg_MODE == VerboseMode)   &
          write(stdout, '(a)') '...' // trim(post) // '  ' // trim(xstring)
     case(msg_info)
       IF (msg_MODE >= NormalMode)   &
          write(stdout, '(a)') 'INFO' // trim(post) // '  ' // trim(xstring)
     case(msg_warn)
       IF (msg_MODE >= NormalMode) THEN
         write(stderr, '(a)') ' '
         write(stdout, '(a)') 'WARNING' // trim(post) // '  ' // trim(xstring)
       ENDIF
     case(msg_error)
       IF (msg_MODE >= QuietMode) THEN
          write(stderr, '(a)') ' '
          write(stderr, '(a)') 'ERROR' // trim(post) // '  ' // trim(xstring)
        ENDIF
      case(msg_fatal)
       IF (msg_MODE >= QuietMode) THEN
         write(stderr, '(a)') ' '
         write(stderr, '(a)') 'FATAL ERROR' // trim(post) // '  ' // trim(xstring)
         write(stderr, '(a)') ' '
       ENDIF
       call exit(stat)
     case(msg_noin)
       IF (msg_MODE >= NormalMode)   &
          write(stdout, '(a)') trim(xstring)
     end select

   end if

end subroutine message
